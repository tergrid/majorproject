/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.29/esri/copyright.txt for details.
*/
import{_ as t}from"../../../../../chunks/tslib.es6.js";import{findLast as e}from"../../../../../core/arrayUtils.js";import r from"../../../../../core/Logger.js";import{numericHash as o}from"../../../../../core/string.js";import{ShaderBuilder2D as n}from"./ShaderBuilder2D.js";import{Float as s,Int as i,Vec4 as p,Vec2 as a}from"./graph/glsl.js";import{GlslShaderWriter as c}from"./graph/GlslGraphWriter.js";import{ShaderGraphContext as u}from"./graph/ShaderGraphContext.js";import{setReachableUids as y}from"./graph/ShaderGraphNode.js";import{TypedShaderProgram as d}from"./typed/TypedShaderProgram.js";function h(t){return new t}function f(t,e,r){const o=t.constructor[e]??[];t.constructor.hasOwnProperty(e)||Object.defineProperty(t.constructor,e,{value:o.slice()}),t.constructor[e].push(r)}function l(t,e){return(r,o)=>{f(r,"locations",{typeCtor:e,propertyKey:o,parameterIndex:null,index:t})}}const m=t=>(e,r)=>{f(e,"builtins",{builtin:t,propertyKey:r})},g=t=>(e,r,o)=>{f(e,"inputs",{inputCtor:t,propertyKey:r,parameterIndex:o})},_=t=>(e,r)=>{f(e,"uniforms",{typeCtor:t,propertyKey:r})},K=t=>(e,r)=>{f(e,"options",{typeCtor:t,propertyKey:r})},x=(t,e)=>{f(t,"defines",{propertyKey:e})};function C(t){return(e,r)=>{f(e,"transformFeedbackBindings",{propertyKey:r,parameterIndex:null,index:t})}}const I=(t,e)=>(r,o)=>{r.constructor.builtins.push({builtin:t,propertyKey:o,typeCtor:e})};class b{}b.builtins=[],t([I("gl_VertexID",i)],b.prototype,"glVertexID",void 0);class v{}class w{}w.builtins=[],t([I("gl_FragCoord",p)],w.prototype,"glFragCoord",void 0),t([I("gl_PointCoord",a)],w.prototype,"glPointCoord",void 0);class F{}t([m("gl_FragColor")],F.prototype,"glFragColor",void 0);class P{constructor(){this.type="uniform-group"}get _uniforms(){return this.constructor.uniforms??[]}}class j{constructor(){this.logShader=!1,this.computeAttributes={}}get vertexInput(){const t=e(this._shaderModuleClass.inputs,(t=>"vertex"===t.propertyKey&&0===t.parameterIndex));if(!t)throw new Error("Unable to find vertex input parameter");return t}get computeInput(){return e(this._shaderModuleClass.inputs,(t=>"vertex"===t.propertyKey&&1===t.parameterIndex))}get fragmentInput(){const t=e(this._shaderModuleClass.inputs,(t=>"fragment"===t.propertyKey));if(!t)throw new Error("Unable to find fragment input parameter");return t}get transformFeedbackBindings(){return this.fragmentInput.inputCtor.transformFeedbackBindings??[]}get locations(){return[...this.vertexInput.inputCtor.locations,...this.computeInput?.inputCtor.locations??[]]}get locationsMap(){const t=new Map,e=new Set;for(const o of this.locations)e.has(o.index)?r.getLogger("esri.views.2d.engine.webgl.shaderGraph.GraphShaderModule").warnOnce("mapview-rendering",`Unable to assigned attribute ${o.propertyKey} to ${o.index}. Index already in use`,{locationsMap:t}):(t.set(o.propertyKey,o.index),e.add(o.index));return t}get locationInfo(){if(!this._locationInfo){const t=this.locationsMap,e=Array.from(t.entries()).map((([t,e])=>`${t}.${e}`)).join("."),r=o(e);this._locationInfo={hash:r,locations:t}}return this._locationInfo}get renamedLocationsMap(){const t=new Map;for(const e of this.locations)t.set("a_"+e.propertyKey,e.index);return t}get optionPropertyKeys(){if(!this._optionPropertyKeys){const t=new Set;for(const e of this._options)t.add(e.propertyKey);this._optionPropertyKeys=t}return this._optionPropertyKeys}get _shaderModuleClass(){return this.constructor}get _defines(){return this._shaderModuleClass.defines??[]}get _options(){return this._shaderModuleClass.options??[]}get _uniforms(){return this._shaderModuleClass.uniforms??[]}getProgram(t,e,r,o){try{const{vertex:n,fragment:s,uniformBindings:i}=this._generateShaders(t,e,r,o);return new d(n,s,this.renamedLocationsMap,this.locationInfo,i,this.transformFeedbackBindings)}catch(n){return console.error("Failed to create program",{error:n}),new d("","",this.renamedLocationsMap,this.locationInfo,[],this.transformFeedbackBindings)}}getDebugUniformClassInfo(t){const e=this._options.find((e=>e.propertyKey===t));if(e)return{type:"option",className:e.typeCtor};const r=this._uniforms.find((e=>e.propertyKey===t));if(!r)throw new Error(`Unable to find uniform class type for property: ${t}`);return{type:"required",className:r.typeCtor}}getShaderKey(t,e,r,o){const n=Object.keys(r).map((t=>`${t}.${r[t]}`)).join("."),s=Object.keys(o).map((t=>`${t}.${o[t]}`)).join("."),i=Object.keys(e).filter((t=>this.optionPropertyKeys.has(t)&&e[t])).join(".");return`${this.constructor.name}.${t.hash}.${n}.${s}.${i}`}_generateShaders(t,e,r,o){const n=[];this._setDefines(r),this._setOptionalUniforms(n,e),this._setRequiredUniforms(n);const s=this._hydrateVertexInput(o),i=this._injectPackPrecisionFactor(s,t),p=this._hydrateComputeInput(),a=p&&this._injectPackPrecisionFactor(p,t),d=this.vertex(i,a),h=this._hydrateFragmentInput(d),f=this.fragment(h),l=new Set;for(const c in f){const t=f[c];y(l,t)}const m=this._getVertexInputBuiltins(),g=u.createVertex({...s,...p},d,m,n,this.transformFeedbackBindings,l);(new c).write(g);const _=this._getFragmentInputBuiltins(f);_.set("glPointCoord","gl_PointCoord");const K=u.createFragment(h,f,_,n,g,this.transformFeedbackBindings);(new c).write(K);const x=this._createShaderBuilder(g,K),C=x.generate("vertex",!1),I=x.generate("fragment",!1);return this.logShader&&(console.log(C),console.log(I)),{vertex:C,fragment:I,uniformBindings:n}}_setDefines(t){for(const e in t)this[e]=t[e]}_setOptionalUniforms(t,e){for(const r of this._options){e[r.propertyKey]?this[r.propertyKey]=this._hydrateUniformGroup(t,r):this[r.propertyKey]=null}}_setRequiredUniforms(t){for(const e of this._uniforms)this[e.propertyKey]=this._hydrateUniformGroup(t,e)}_hydrateUniformGroup(t,e){const r=new(0,e.typeCtor);for(const o of r._uniforms??[]){const n=h(o.typeCtor),s=`u_${e.propertyKey}_${o.propertyKey}`,i=n.type,p=[e.propertyKey,o.propertyKey].join(".");if("type"in o.typeCtor&&"array"===o.typeCtor.type){const e=n;t.push({shaderModulePath:p,uniformName:s,uniformType:i,uniformArrayLength:e.size,uniformArrayElementType:e.elementType.type,uniformHydrated:n})}else t.push({shaderModulePath:p,uniformName:s,uniformType:i,uniformHydrated:n});r[o.propertyKey]=n}return r}_hydrateVertexInput(t){const e=this.vertexInput.inputCtor,r=e.locations.reduce(((e,r)=>!1===t[r.propertyKey]?e:{...e,[r.propertyKey]:h(r.typeCtor)}),{});for(const{propertyKey:o,typeCtor:n}of e.builtins){const t=h(n);r[o]=t}return r}_hydrateComputeInput(){if(null==this.computeInput)return null;return this.computeInput.inputCtor.locations.reduce(((t,e)=>({...t,[e.propertyKey]:h(e.typeCtor)})),{})}_injectPackPrecisionFactor(t,e){const r={};for(const o in t){const n=t[o],i=e.attributes.find((t=>t.name===o));if(i?.packPrecisionFactor){if("float"!==n.type&&"vec2"!==n.type&&"vec3"!==n.type&&"vec4"!==n.type)throw new Error(`InternalError: packPrecisionFactor requires GenType, but found ${n.type}`);r[o]=n.divide(new s(i.packPrecisionFactor))}else r[o]=n}return r}_hydrateFragmentInput(t){const e={};for(const r in t)e[r]=t[r];for(const{propertyKey:r,typeCtor:o}of w.builtins){const t=h(o);e[r]=t}return e}_getVertexInputBuiltins(){const t=this.vertexInput.inputCtor,e=new Map;for(const{builtin:r,propertyKey:o}of t.builtins)e.set(o,r);return e}_getFragmentInputBuiltins(t){const e=t.constructor,r=new Map;for(const o of e.builtins??[])r.set(o.propertyKey,o.builtin);return r}_createShaderBuilder(t,e){const r=new n;return this._insertDebugInfo(r),t.insertVertexShader(r),e.insertFragmentShader(r),r}_insertDebugInfo(t){t.vertex.code.add("// DEFINES: "),t.vertex.code.add("// --------------------------------------------------------- ");for(const e of this._defines)this[e.propertyKey]?t.vertex.code.add(`//   ${e.propertyKey}: true`):t.vertex.code.add(`//   ${e.propertyKey}: false`);t.vertex.code.add(""),t.vertex.code.add("// OPTIONS: "),t.vertex.code.add("// --------------------------------------------------------- ");for(const e of this._options)this[e.propertyKey]?t.vertex.code.add(`//   ${e.propertyKey}: true`):t.vertex.code.add(`//   ${e.propertyKey}: false`)}}export{v as ComputeVertexInput,w as FragmentInput,F as FragmentOutput,j as GraphShaderModule,P as UniformGroup,b as VertexInput,m as builtin,x as define,g as input,l as location,K as option,C as transformFeedback,_ as uniform};
