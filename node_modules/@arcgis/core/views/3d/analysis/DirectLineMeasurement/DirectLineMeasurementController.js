/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.29/esri/copyright.txt for details.
*/
import{_ as e}from"../../../../chunks/tslib.es6.js";import t from"../../../../core/Accessor.js";import i from"../../../../core/Logger.js";import{createLength as o}from"../../../../core/quantityUtils.js";import{watch as r,syncAndInitial as s}from"../../../../core/reactiveUtils.js";import{property as n}from"../../../../core/accessorSupport/decorators/property.js";import"../../../../core/has.js";import"../../../../core/RandomLCG.js";import{subclass as a}from"../../../../core/accessorSupport/decorators/subclass.js";import{q as l}from"../../../../chunks/vec32.js";import{create as c}from"../../../../core/libs/gl-matrix-2/factories/vec3f64.js";import{geodesicLength as m}from"../../../../geometry/geometryEngine.js";import p from"../../../../geometry/Polyline.js";import{canProjectWithoutEngine as u}from"../../../../geometry/projection.js";import d from"../../../../geometry/SpatialReference.js";import{getSphericalPCPF as h,SphericalECEFSpatialReference as f,WGS84ECEFSpatialReference as v}from"../../../../geometry/spatialReferenceEllipsoidUtils.js";import{projectPointToVector as j}from"../../../../geometry/projection/projectPointToVector.js";import{projectPointToWGS84ComparableLonLat as g}from"../../../../geometry/projection/projectPointToWGS84ComparableLonLat.js";import{isSupported as P,geodesicLengths as y,inverseGeodeticSolver as _,InverseGeodeticSolverResult as D}from"../../../../geometry/support/geodesicUtils.js";import{MeasurementMode as w}from"../interfaces.js";import{applyProjectionAndElevationAlignment as z,logFailedGeometryProjectionError as R}from"../support/projectionUtils.js";import{UnitNormalizer as A}from"../support/UnitNormalizer.js";import{geodesicDistanceThreshold as E}from"../../../support/geodesicMeasurementUtils.js";let b=class extends t{constructor(e){super(e),this._unitNormalizer=new A,this._tempStartPosition=c(),this._tempEndPosition=c(),this._tempCornerPosition=c()}initialize(){const e=this.view.spatialReference,t=h(e),i=t===f?v:t;this._sphericalPCPF=i;const o=u(e,i);this._unitNormalizer.spatialReference=o?i:e,this.addHandles([r((()=>({viewData:this.viewData,startPoint:this.analysis.startPoint})),(({viewData:e,startPoint:t})=>{e.elevationAlignedStartPoint=this._applyProjectionAndElevationAlignment(t)}),s),r((()=>({viewData:this.viewData,endPoint:this.analysis.endPoint})),(({viewData:e,endPoint:t})=>{e.elevationAlignedEndPoint=this._applyProjectionAndElevationAlignment(t)}),s),r((()=>({result:this._computedResult,viewData:this.viewData})),(({result:e,viewData:t})=>{t.result=e}),s)])}_applyProjectionAndElevationAlignment(e){if(null==e)return e;const{spatialReference:t,elevationProvider:o}=this.view,r=z(e,t,o);return r??(R(this.analysis,e.spatialReference,i.getLogger(this)),null)}get _computedResult(){const{elevationAlignedStartPoint:e,elevationAlignedEndPoint:t,measurementMode:i}=this.viewData;if(null==e||null==t)return null;const o=this._euclideanDistances(e,t),r=this._geodesicDistance(e,t);let s,n;switch(i){case w.Auto:n=null!=r?"geodesic":"euclidean",s=r??o.horizontal;break;case w.Geodesic:if(null==r)return null;n="geodesic",s=r;break;case w.Euclidean:n="euclidean",s=o.horizontal}return{mode:n,directDistance:o.direct,horizontalDistance:s,verticalDistance:o.vertical,distance:i===w.Euclidean||o.horizontal.value<=E?o.direct:r??o.horizontal}}_euclideanDistances(e,t){const i=e.clone();i.z=t.z;const r=this._tempStartPosition,s=this._tempEndPosition,n=this._tempCornerPosition,a=this.view.spatialReference,c=this._sphericalPCPF,m=u(a,c)?c:a;j(e,r,m),j(t,s,m),j(i,n,m);const p=l(r,s),d=l(n,s),h=Math.abs(t.z-e.z),f=e=>this._unitNormalizer.normalizeDistance(e),v=f(p),g=f(d),P=f(h);return{direct:o(v,"meters"),horizontal:o(g,"meters"),vertical:o(P,"meters")}}_geodesicDistance(e,t){const{spatialReference:i}=e,r=new p({spatialReference:i});r.addPath([e,t]);const s=i.isGeographic&&P(i)?y([r],"meters")[0]:i.isWebMercator?m(r,"meters"):null,n=null!=s?s:this._fallbackGeodesicDistance(e,t);return null!=n?o(n,"meters"):null}_fallbackGeodesicDistance(e,t){if(g(e,S)&&g(t,C)){const e=new D;return _(e,S,C,d.WGS84),e.distance}return null}};e([n()],b.prototype,"view",void 0),e([n()],b.prototype,"analysis",void 0),e([n()],b.prototype,"viewData",void 0),e([n()],b.prototype,"_computedResult",null),b=e([a("esri.views.3d.analysis.DirectLineMeasurement.DirectLineMeasurementController")],b);const S=c(),C=c();export{b as DirectLineMeasurementController};
