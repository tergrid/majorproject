/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.29/esri/copyright.txt for details.
*/
import e from"../../../Color.js";import{multiplyOpacity as n}from"../../../core/colorUtils.js";import"../../../core/has.js";import{destroyHandle as i}from"../../../core/handleUtils.js";import{m as t}from"../../../chunks/vec32.js";import{create as r}from"../../../core/libs/gl-matrix-2/factories/vec3f64.js";import{projectVectorToVector as o}from"../../../geometry/projection/projectVectorToVector.js";import{onTheGroundElevationInfo as a,absoluteHeightElevationInfo as l}from"../../../support/elevationInfoUtils.js";import{ExtendedLineVisualElement as s,ExtensionType as c}from"./visualElements/ExtendedLineVisualElement.js";import{ParallelLineVisualElement as p}from"./visualElements/ParallelLineVisualElement.js";import{PointVisualElement as d}from"./visualElements/PointVisualElement.js";import{RightAngleQuadVisualElement as m}from"./visualElements/RightAngleQuadVisualElement.js";import{DrapedRenderGroup as u}from"../layers/interfaces.js";import{RenderOccludedFlag as f}from"../webgl-engine/lib/Material.js";import{toDehydratedPoint as g,create as v}from"../../interactive/sketch/normalizedPoint.js";import{defaults as h}from"../../interactive/snapping/Settings.js";import{SnappingDomain as E}from"../../interactive/snapping/SnappingDomain.js";import{LineSegmentHintType as C}from"../../interactive/snapping/snappingUtils.js";import{SnappingVisualizer as S}from"../../interactive/snapping/SnappingVisualizer.js";import{LineSnappingHint as j}from"../../interactive/snapping/hints/LineSnappingHint.js";import{vectorToRender as w}from"../../interactive/support/viewUtils.js";class O extends S{sortUniqueHints(e){return e.sort(((e,n)=>(n instanceof j?n.length:0)-(e instanceof j?e.length:0)))}visualizeIntersectionPoint(e,n){const{spatialReference:t,view:r}=n,o=D(n);return i(new d({view:r,primitive:"circle",geometry:g(e.intersectionPoint,t),elevationInfo:e.isDraped?a:l,size:20,outlineSize:2,color:o.intersectionPointColor,outlineColor:o.intersectionPointOutlineColor,pixelSnappingEnabled:!1,isDecoration:!0,attached:!0}))}visualizePoint(e,n){const{view:t,spatialReference:r}=n,o=D(n),a=R(e.point,e.domain,n);return i(new d({view:t,primitive:"circle",geometry:g(a,r),elevationInfo:x(e,n),size:20,outlineSize:2,color:o.pointColor,outlineColor:o.pointOutlineColor,pixelSnappingEnabled:!1,isDecoration:!0,attached:!0}))}visualizeLine(e,n){const{view:t,spatialReference:r}=n,o=D(n),a=R(e.lineStart,e.domain,n),l=R(e.lineEnd,e.domain,n);return i(this._createLineSegmentHint(e.type,a,l,r,x(e,n),t,o,e.isDraped,e.fadeLeft,e.fadeRight))}visualizeParallelSign(e,n){const{view:r,spatialReference:o}=n,a=D(n),{isDraped:l}=e,s=x(e,n),c=R(e.lineStart,e.domain,n),d=R(e.lineEnd,e.domain,n),m=H(c,o,s,r,l),g=H(d,o,s,r,l),v=t(g,m,g,.5),E=new p({view:r,attached:!1,offset:h.parallelLineHintOffset,length:h.parallelLineHintLength,width:h.parallelLineHintWidth,color:a.parallelSignColor,location:v,renderOccluded:l?f.OccludeAndTransparent:f.Opaque,isDraped:l,renderGroup:u.SnappingHint,isDecoration:!0});return E.setDirectionFromPoints(m,v),E.attached=!0,i(E)}visualizeRightAngleQuad(e,n){const{view:t,spatialReference:r}=n,o=D(n),a=x(e,n),{isDraped:l}=e,s=R(e.previousVertex,e.domain,n),c=R(e.centerVertex,e.domain,n),p=R(e.nextVertex,e.domain,n),d=H(s,r,a,t,l),g=H(c,r,a,t,l),v=H(p,r,a,t,l);return i(new m({view:t,attached:!0,color:l?o.rightAngleColorDraped:o.rightAngleColor,renderOccluded:l?f.OccludeAndTransparent:f.Transparent,outlineRenderOccluded:l?f.OccludeAndTransparent:f.Opaque,outlineColor:o.rightAngleOutlineColor,outlineSize:h.rightAngleHintOutlineSize,size:h.rightAngleHintSize,isDraped:l,geometry:{previous:d,center:g,next:v},renderGroup:u.SnappingHint,isDecoration:!0}))}_createLineSegmentHint(e,n,i,t,r,o,a,l=!1,p=!0,d=!0){const m=H(n,t,r,o,l),g=H(i,t,r,o,l),v=new s({view:o,extensionType:c.FADED,start:m,end:g,isDraped:l,color:a.lineColor,renderOccluded:l?f.OccludeAndTransparent:f.Opaque,renderGroup:u.SnappingHint,isDecoration:!0});switch(e){case C.TARGET:v.width=h.lineHintWidthTarget,v.fadedExtensions={start:0,end:h.lineHintFadedExtensions};break;case C.REFERENCE_EXTENSION:v.width=h.lineHintWidthReference,v.fadedExtensions={start:0,end:0};break;case C.REFERENCE:v.width=h.lineHintWidthReference,v.fadedExtensions={start:p?h.lineHintFadedExtensions:0,end:d?h.lineHintFadedExtensions:0}}return v.attached=!0,v}}function D(i){const{effectiveTheme:t}=i.view,r=e.toUnitRGBA(t.accentColor),o=[0,0,0,0];return{intersectionPointColor:o,intersectionPointOutlineColor:r,pointColor:o,pointOutlineColor:r,lineColor:r,lineOutlineColor:void 0,parallelSignColor:r,rightAngleColor:r,rightAngleColorDraped:e.toUnitRGBA(n(t.accentColor,.5)),rightAngleOutlineColor:r}}function R(e,n,i){const t=A(n,i);return null==t?e:v(e[0],e[1],t)}function x(e,n){return null!=A(e.domain,n)?n.selfSnappingZ.elevationInfo:e.isDraped?a:l}function A(e,{selfSnappingZ:n}){return e===E.SELF&&null!=n?n.value:null}function H(e,n,i,t,a){const l=r();if(a){const i=t.basemapTerrain.overlayManager.renderer.spatialReference;o(e,n,l,i)}else w(e,n,i,t,l);return l}export{O as SnappingVisualizer3D};
