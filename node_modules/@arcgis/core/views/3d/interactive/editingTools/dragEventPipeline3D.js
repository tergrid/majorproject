/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.29/esri/copyright.txt for details.
*/
import"../../../../geometry.js";import{screenPointObjectToArray as e,castScreenPointArray as n,createScreenPointArray as r}from"../../../../core/screenUtils.js";import{l as t,c as o,b as l,f as s,k as c,h as i,g as a}from"../../../../chunks/vec32.js";import{create as u}from"../../../../core/libs/gl-matrix-2/factories/vec3f64.js";import{projectPoint as p}from"../../../../geometry/projection.js";import{intersectRay as m,create as d,getNormal as f,fromPositionAndNormal as g}from"../../../../geometry/support/plane.js";import{create as y}from"../../../../geometry/support/ray.js";import{projectPoint as E}from"../../../../geometry/support/vector.js";import{sv2d as S}from"../../../../geometry/support/vectorStacks.js";import{getZForElevationMode as j,getGraphicEffectiveElevationInfo as R}from"../../../../support/elevationInfoUtils.js";import{fromScreen as v}from"../../support/geometryUtils/ray.js";import{newIntersector as x}from"../../webgl-engine/lib/Intersector.js";import{StoreResults as b,IntersectorType as w}from"../../webgl-engine/lib/IntersectorInterfaces.js";import{terrainId as I}from"../../webgl-engine/lib/verticalOffsetUtils.js";import{EventPipeline as H}from"../../../interactive/dragEventPipeline.js";import U from"../../../../geometry/Point.js";function O(e,n){return P(e,(()=>n))}function C(e){return P(e,(e=>e.plane))}function P(r,t){const o=u(),l=u();let s=!1;return c=>{const i=t(c);if("start"===c.action){const t=e(c.screenStart,n(S.get())),l=v(r.state.camera,t,K);null!=l&&(s=m(i,l,o))}if(!s)return null;const a=e(c.screenEnd,n(S.get())),u=v(r.state.camera,a,K);return null==u?null:m(i,u,l)?{...c,renderStart:o,renderEnd:l,plane:i,ray:u}:null}}function T(e,n,t=0,o=null,l=null){let s=null;return c=>{if("start"===c.action&&(s=e.sceneIntersectionHelper.intersectElevationFromScreen(r(c.screenStart.x,c.screenStart.y),n,t,l),null!=s&&null!=o&&!p(s,s,o)))return null;if(null==s)return null;const i=e.sceneIntersectionHelper.intersectElevationFromScreen(r(c.screenEnd.x,c.screenEnd.y),n,t,l);return null!=i&&(null==o||p(i,i,o))?{...c,mapStart:s,mapEnd:i}:null}}function D(e,n,r,t=null,o=null){return T(e,r,j(n,e,r),t,o)}function M(e,n,r,t=null,o=null){return D(e,r,R(n),t,o)}function N(e,n,r,t){const o=n.toMap(e.screenStart,{include:[r]});return null!=o?M(n,r,o,t):null}function h(e,n){const r=B,t=J,o=d();e.renderCoordsHelper.worldUpAtPosition(n,r);const c=l(f(o),r,s(t,n,e.state.camera.eye));return l(c,c,r),g(n,c,o)}function k(e,n,r){let t=null;const o=new H;return o.next(O(e,h(e,n))).next(G(e,n)).next(A(e,r)).next((e=>{e.mapEnd.x=e.mapStart.x,e.mapEnd.y=e.mapStart.y,t=e})),e=>(t=null,o.execute(e),t)}function G(e,n){const r=u(),l=t(n);e.renderCoordsHelper.worldUpAtPosition(n,r);const p=u(),m=u(),d=o=>{if(s(o,o,n),E(r,o,o),"global"===e.viewingMode){t(o)*Math.sign(c(r,o))<.001-l&&s(o,i(o,r,.001),n)}return a(o,o,n),o};return e=>(e.renderStart=d(o(p,e.renderStart)),e.renderEnd=d(o(m,e.renderEnd)),e)}function A(e,n){const r=e.renderCoordsHelper;return e=>{const t=r.fromRenderCoords(e.renderStart,new U({spatialReference:n})),o=r.fromRenderCoords(e.renderEnd,new U({spatialReference:n}));return null!=t&&null!=o?{...e,mapStart:t,mapEnd:o}:null}}var F;function q(e){let n=null;return r=>{switch(r.action){case"start":n=e.disableDisplay();break;case"end":case"cancel":null!=n&&(n.remove(),n=null)}return r}}function z(n,t=null){const o=x(n.state.viewingMode);o.options.selectionMode=!0,o.options.store=b.MIN,o.options.hud=!1;const l=r(),s={requiresGroundFeedback:!0,enableDraped:!0,exclude:new Set},c=u(),i=t??n.spatialReference,a=r=>{n.map.ground&&n.map.ground.opacity<1?s.exclude.add(I):s.exclude.delete(I),n.sceneIntersectionHelper.intersectIntersectorScreen(e(r,l),o,s);const t=o.results.min;let a;if(t.getIntersectionPoint(c))a=t.intersector===w.TERRAIN?F.GROUND:F.OTHER;else{if(!o.results.ground.getIntersectionPoint(c))return null;a=F.GROUND}return{location:n.renderCoordsHelper.fromRenderCoords(c,new U({spatialReference:i})),surfaceType:a}};let p;return e=>{if("start"===e.action){const n=a(e.screenStart);p=null!=n?n.location:null}if(null==p)return null;const n=a(e.screenEnd);return null!=n?.location?{...e,mapStart:p,mapEnd:n.location,surfaceType:n.surfaceType}:null}}!function(e){e[e.GROUND=0]="GROUND",e[e.OTHER=1]="OTHER"}(F||(F={}));const B=u(),J=u(),K=y();export{F as SurfaceType,A as convertToMapCoordinates,q as hideManipulatorWhileDragging,G as projectToWorldUp,z as screenToMap3D,D as screenToMapXYAtLocation,N as screenToMapXYForGraphic,M as screenToMapXYForGraphicAtLocation,O as screenToRenderPlane,C as screenToRenderPlaneFromEvent,k as screenToZConstrained};
