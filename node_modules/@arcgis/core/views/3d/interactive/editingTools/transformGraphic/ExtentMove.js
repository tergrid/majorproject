/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.29/esri/copyright.txt for details.
*/
import{zeroMeters as t}from"../../../../../core/quantityUtils.js";import{rotateZ as e}from"../../../../../core/libs/gl-matrix-2/math/mat4.js";import{f as i}from"../../../../../chunks/vec32.js";import{clone as o}from"../../../../../core/libs/gl-matrix-2/factories/vec3f64.js";import{sm4d as a,sv3d as r}from"../../../../../geometry/support/vectorStacks.js";import{ShiftManipulator as n,OffsetMode as s}from"../../../analysis/Slice/ShiftManipulator.js";import{IsShiftEdgeOnScreenFlag as p}from"../../../analysis/Slice/sliceToolUtils.js";import{screenToZConstrained as l}from"../dragEventPipeline3D.js";import{ManipulatorType as c}from"../ManipulatorType.js";import{MoveXYGraphicManipulation as m}from"../manipulations/MoveXYGraphicManipulation.js";import{createManipulatorDragEventPipeline as h,addScreenDelta as u,addMapDelta as d}from"../../../../interactive/dragEventPipeline.js";import{AccumulationBehavior as v}from"../../../../interactive/editGeometry/interfaces.js";import{apply as f}from"../../../../interactive/editGeometry/support/editPlaneUtils.js";import{TranslateGraphicTooltipInfo as g,TranslateGraphicZTooltipInfo as _}from"../../../../interactive/tooltip/TranslateTooltipInfos.js";import{autoDistance2D as M}from"../../../../support/automaticLengthMeasurementUtils.js";import{verticalSignedDistance as S}from"../../../../support/euclideanLengthMeasurementUtils.js";class y{constructor(t,e,i,o){this._tool=t,this._graphicState=e,this._editGeometryOperations=i,this._bounds=o,this._moveXYTooltipInfo=null,this._moveZTooltipInfo=null;const a=this._tool,r=a.view;this.moveXYGraphicManipulation=new m({view:r,tool:a,graphicState:this._graphicState}),a.addHandles(this._createMoveXYGraphicDragPipeline()),this.moveZManipulator=new n(r,s.CENTER_ON_CALLOUT),this.moveZManipulator.state|=p,a.manipulators.add(this.moveZManipulator),a.addHandles([this._createMoveZDragPipeline()]),a.addHandles([a.on("graphic-translate-stop",(()=>{this._moveXYTooltipInfo=null,this._moveZTooltipInfo=null}))])}destroy(){this.moveXYGraphicManipulation.destroy(),this._tool.manipulators.remove(this.moveZManipulator),this.moveZManipulator.destroy()}forEachManipulator(t){this.moveXYGraphicManipulation.forEachManipulator(t),t(this.moveZManipulator,c.TRANSLATE_Z)}updateManipulators(t,o){const n=this.moveZManipulator,s=e(a.get(),t,Math.PI);s[12]=0,s[13]=0,s[14]=0,n.modelTransform=s,n.renderLocation=i(r.get(),o.origin,o.basis1)}getUpdatedTooltipInfo(){return this.moveXYGraphicManipulation.grabbing||this.moveXYGraphicManipulation.dragging?this._computeMoveXYTooltipInfo():this.moveZManipulator.focused?this._computeMoveZTooltipInfo():null}_computeMoveXYTooltipInfo(){const e=this._tool,i=this._moveXYTooltipInfo??=new g({sketchOptions:e.sketchOptions});if(this.moveXYGraphicManipulation.dragging){const t=this._bounds,o=t.mapBoundsStart.origin,a=t.mapBounds.origin,{renderSpatialReference:r}=e.view;if(!r)return null;const n=M(o,a,r);if(null==n)return null;i.distance=n}else i.distance=t;return i}_computeMoveZTooltipInfo(){const e=this._tool,i=this._moveZTooltipInfo??=new _({sketchOptions:e.sketchOptions});if(this.moveZManipulator.dragging){const t=this._bounds,o=t.mapBoundsStart.origin,a=t.mapBounds.origin,{renderSpatialReference:r}=e.view;if(!r)return null;const n=S(o,a,r);if(null==n)return null;i.distance=n}else i.distance=t;return i}_createMoveXYGraphicDragPipeline(){return this.moveXYGraphicManipulation.createDragPipeline(((t,e,i)=>this._applyGraphicMoveSteps(e,i)))}_createMoveZDragPipeline(){const t=this._editGeometryOperations.data.spatialReference;return h(this.moveZManipulator,((e,i,a)=>{const r=o(e.renderLocation),n=i.next(l(this._tool.view,r,t)).next(u());this._applyGraphicMoveSteps(n,a)}))}_applyGraphicMoveSteps(t,e){const i=this._tool,o=i.graphic,a=t.next((t=>("start"===t.action&&(i.inputState={type:"move"},this._bounds.backupMapBounds(),i.emit("graphic-translate-start",{graphic:o,dxScreen:t.screenDeltaX,dyScreen:t.screenDeltaY})),t))).next(d()).next(this._moveDragUpdateGeometry()).next((t=>{const e={graphic:o,dxScreen:t.screenDeltaX,dyScreen:t.screenDeltaY};switch(t.action){case"start":case"update":(t.mapEnd.x-t.mapStart.x||t.mapEnd.y-t.mapStart.y||(t.mapEnd.z??0)-(t.mapStart.z??0))&&i.emit("graphic-translate",e);break;case"end":i.inputState=null,i.emit("graphic-translate-stop",e)}return t}));return e.next((()=>{null!=i.inputState&&i.emit("graphic-translate-stop",{graphic:o,dxScreen:0,dyScreen:0}),i.cancel()})),a}_moveDragUpdateGeometry(){const t=this._tool;return e=>{if(null==t.inputState||"move"!==t.inputState.type)return e;const i=[];for(const t of this._editGeometryOperations.data.components)i.push(...t.vertices);const o="start"===e.action?v.NEW_STEP:v.ACCUMULATE_STEPS,a=this._editGeometryOperations.moveVertices(i,e.mapDeltaX,e.mapDeltaY,e.mapDeltaZ,o);return f(a,this._bounds.mapBounds),t.graphic.geometry=this._editGeometryOperations.data.geometry,e}}}export{y as ExtentMove};
