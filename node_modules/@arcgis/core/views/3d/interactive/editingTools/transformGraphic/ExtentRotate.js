/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.29/esri/copyright.txt for details.
*/
import{rad2deg as t}from"../../../../../core/mathUtils.js";import{rotateX as e}from"../../../../../core/libs/gl-matrix-2/math/mat4.js";import{g as o,c as r}from"../../../../../chunks/vec32.js";import{create as a}from"../../../../../core/libs/gl-matrix-2/factories/vec3f64.js";import{c as i}from"../../../../../chunks/boundedPlane.js";import{create as s,intersectRay as n,getNormal as p}from"../../../../../geometry/support/plane.js";import{sm4d as l,sv3d as c}from"../../../../../geometry/support/vectorStacks.js";import{getRotateHeadingTexture as m}from"../../../analysis/images/Factory.js";import{RotateManipulator as u}from"../../../analysis/Slice/RotateManipulator.js";import{createRotatePlane as h,RotationAxis as d}from"../../../analysis/Slice/sliceToolUtils.js";import{calculateInputRotationTransform as g}from"../../manipulatorUtils.js";import{screenToRenderPlane as _}from"../dragEventPipeline3D.js";import{ManipulatorType as f}from"../ManipulatorType.js";import{fromScreenNormalized as y}from"../../../support/geometryUtils/ray.js";import{createManipulatorDragEventPipeline as j}from"../../../../interactive/dragEventPipeline.js";import{AccumulationBehavior as v}from"../../../../interactive/editGeometry/interfaces.js";import{AccumulationType as A}from"../../../../interactive/editGeometry/operations/UpdateVertices.js";import{apply as M}from"../../../../interactive/editGeometry/support/editPlaneUtils.js";import{ExtentRotateTooltipInfo as P}from"../../../../interactive/tooltip/ExtentTooltipInfos.js";class T{constructor(t,e,o){this._tool=t,this._editGeometryOperations=e,this._bounds=o,this._rotateTooltipInfo=null,this._startAngle=0,this._endAngle=0;const r=this._tool,a=r.view,i=!a._stage?.renderView.renderingContext.driverTest.svgPremultipliesAlpha.result;this.rotateManipulator=new u(a,((t,e)=>m(a.textures,{accentColor:t,contrastColor:e,preMultiplyAlpha:i}))),r.addHandles([this.rotateManipulator.events.on("grab-changed",(t=>this._onRotateGrab(t))),this._createRotateDragPipeline(this.rotateManipulator)]),r.manipulators.add(this.rotateManipulator),r.addHandles([r.on("graphic-rotate-start",(t=>{this._startAngle=t.angle})),r.on("graphic-rotate",(t=>{this._endAngle=t.angle})),r.on("graphic-rotate-stop",(()=>{this._startAngle=0,this._endAngle=0}))])}destroy(){this._tool.manipulators.remove(this.rotateManipulator),this.rotateManipulator.destroy()}forEachManipulator(t){t(this.rotateManipulator,f.ROTATE)}updateManipulators(t,r){const a=this._bounds.mapBounds.plane[2]<0?Math.PI:0,i=e(l.get(),t,a);i[12]=0,i[13]=0,i[14]=0,this.rotateManipulator.modelTransform=i,this.rotateManipulator.renderLocation=o(c.get(),r.origin,r.basis1)}getUpdatedTooltipInfo(){return this.rotateManipulator.focused?this._computeRotateTooltipInfo():null}_computeRotateTooltipInfo(){const t=this._rotateTooltipInfo??=new P({sketchOptions:this._tool.sketchOptions});return t.angle=this._startAngle-this._endAngle,t}_onRotateGrab({action:t,screenPoint:e}){const o=this._tool,r=this._bounds;if("start"!==t||!e)return;const a=h(r.displayBounds,o.view.renderCoordsHelper,d.HEADING,s()),i=y(o.view.state.camera,e);n(a,i,c.get())&&(r.backupMapBounds(),o.inputState={type:"rotate",rotatePlane:a})}_createRotateDragPipeline(e){const o=this._tool,r=o.graphic;return j(e,((e,a,i)=>{const s=o.inputState;null!=s&&(a.next((t=>("start"===t.action&&o.emit("graphic-rotate-start",{graphic:r,angle:0}),t))).next(_(o.view,s.rotatePlane)).next(this._rotateDragRenderPlaneToRotate(s)).next(this._rotateDragUpdateGeometry()).next((e=>{const a={graphic:r,angle:t(e.rotateAngle)};switch(e.action){case"start":case"update":o.emit("graphic-rotate",a);break;case"end":o.inputState=null,o.emit("graphic-rotate-stop",a)}return e})),i.next((()=>{null!=o.inputState&&o.emit("graphic-rotate-stop",{graphic:r,angle:0}),o.cancel()})))}))}_rotateDragRenderPlaneToRotate(t){return e=>{const o=p(t.rotatePlane),r=g(e.renderStart,e.renderEnd,this._bounds.displayBounds.origin,o);return{...e,rotateAxis:o,rotateAngle:r}}}_rotateDragUpdateGeometry(){const t=this._tool,e=this._bounds;return o=>{const s=r(a(),e.mapBoundsStart.origin),n=[];for(const t of this._editGeometryOperations.data.components)n.push(...t.vertices);const p="start"===o.action?v.NEW_STEP:v.ACCUMULATE_STEPS,l=this._editGeometryOperations.rotateVertices(n,s,o.rotateAngle,p,A.REPLACE);return i(e.mapBoundsStart,e.mapBounds),M(l,e.mapBounds),t.graphic.geometry=this._editGeometryOperations.data.geometry,o}}}export{T as ExtentRotate};
