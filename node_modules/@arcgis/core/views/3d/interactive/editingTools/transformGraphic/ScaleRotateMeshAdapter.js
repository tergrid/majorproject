/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.29/esri/copyright.txt for details.
*/
import{_ as t}from"../../../../../chunks/tslib.es6.js";import e from"../../../../../core/Accessor.js";import{deg2rad as i,rad2deg as o}from"../../../../../core/mathUtils.js";import{when as r,sync as n}from"../../../../../core/reactiveUtils.js";import{property as s}from"../../../../../core/accessorSupport/decorators/property.js";import"../../../../../core/has.js";import"../../../../../core/Logger.js";import"../../../../../core/RandomLCG.js";import{subclass as a}from"../../../../../core/accessorSupport/decorators/subclass.js";import{axis as l,angle as c}from"../../../../../geometry/support/axisAngleDegrees.js";import{createGraphicGeometryUndoRecord as p}from"./undoRecords.js";let g=class extends e{constructor(t){super(t),this._interactionState=null}initialize(){this.addHandles([r((()=>{const t=this._interactionState;return t&&t.angle!==t.previousAngle?{interactionState:t,angle:t.state.angle}:null}),(({interactionState:t})=>{this._updateMeshRotation(t)}),n),r((()=>{const t=this._interactionState;return t&&t.scale!==t.previousScale?{interactionState:t,scale:t.state.scale}:null}),(({interactionState:t})=>{this._updateMeshSize(t)}),n)])}get initialAngle(){return this._interactionState?.initialAngle??0}get angle(){const t=this.geometry.transform;if(null==t)return this._interactionState?.angle??0;const e=l(t.rotation)[2];return Math.abs(e)>.999999?i(c(t.rotation))*Math.sign(e):0}get angleClockwise(){return-this.angle}get relativeAngle(){return this.angle-this.initialAngle}get relativeAngleClockwise(){return-this.relativeAngle}get scale(){return this._interactionState?.scale??1}startInteraction(){const t=new h({angle:this.angle});this._interactionState=t;const e=()=>{this._interactionState=null};return{state:t,done:e,cancel:()=>{t.cancel(),e()}}}createUndoRecord(){return p(this.graphic)}_updateMeshRotation(t){const{angle:e,previousAngle:i}=t;t.previousAngle=e;const r=o(e-i),{geometry:n}=this,s=n.anchor;n.rotate(0,0,r,{origin:s}),n.transform&&n.vertexSpace.origin?this.graphic.notifyMeshTransformChanged():this.graphic.notifyGeometryChanged()}_updateMeshSize(t){const{scale:e,previousScale:i}=t;t.previousScale=e;const{geometry:o}=this,r=e/i,n=this.geometry.anchor;this.geometry.scale(r,{origin:n}),o.transform&&o.vertexSpace.origin?this.graphic.notifyMeshTransformChanged():this.graphic.notifyGeometryChanged()}};t([s({constructOnly:!0})],g.prototype,"graphic",void 0),t([s({constructOnly:!0})],g.prototype,"geometry",void 0),t([s({constructOnly:!0})],g.prototype,"viewingMode",void 0),t([s()],g.prototype,"initialAngle",null),t([s()],g.prototype,"angle",null),t([s()],g.prototype,"angleClockwise",null),t([s()],g.prototype,"relativeAngle",null),t([s()],g.prototype,"relativeAngleClockwise",null),t([s()],g.prototype,"scale",null),t([s()],g.prototype,"_interactionState",void 0),g=t([a("esri.views.3d.interactive.editingTools.transformGraphic.ScaleRotateMeshAdapter")],g);let h=class extends e{get state(){const{angle:t,scale:e}=this;return{angle:t,scale:e}}constructor(t){super(t),this.angle=0,this.initialAngle=0,this.previousAngle=0,this.previousScale=1,this.scale=1,this.initialAngle=t.angle,this.previousAngle=t.angle}cancel(){this.angle=this.initialAngle,this.scale=1}};t([s()],h.prototype,"angle",void 0),t([s()],h.prototype,"initialAngle",void 0),t([s()],h.prototype,"previousAngle",void 0),t([s()],h.prototype,"previousScale",void 0),t([s()],h.prototype,"scale",void 0),t([s()],h.prototype,"state",null),h=t([a("InteractionState")],h);export{g as ScaleRotateMeshAdapter};
