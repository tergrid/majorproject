/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.29/esri/copyright.txt for details.
*/
import{n as e,z as t,k as i,r as s,c as n,H as r,w as o,h as a,o as c,a as l,q as h,l as d,p as u,f as m,g as p}from"../../../../chunks/vec32.js";import{create as _}from"../../../../core/libs/gl-matrix-2/factories/vec3f64.js";import{c as v,h as g}from"../../../../chunks/vec42.js";import{create as f}from"../../../../core/libs/gl-matrix-2/factories/vec4f64.js";import{getReferenceEllipsoid as S}from"../../../../geometry/ellipsoidUtils.js";import{getSphericalPCPF as R}from"../../../../geometry/spatialReferenceEllipsoidUtils.js";import{projectBoundingSphere as b}from"../../../../geometry/projection/projectBoundingSphere.js";import{getProjector as x}from"../../../../geometry/projection/projectors.js";import{create as M,fromMatrix as I,intersectsSphere as C,createPoints as P}from"../../../../geometry/support/frustum.js";import{isPlateCarree as E}from"../../../../geometry/support/spatialReferenceUtils.js";import{g as D,w as F}from"../../../../chunks/sphere.js";import{makeDehydratedPoint as O}from"../../../../layers/graphics/dehydratedPoint.js";import{ViewingMode as B}from"../../../ViewingMode.js";import{evaluateElevationAlignmentAtPoint as V}from"../graphics/elevationAlignmentUtils.js";import{ElevationContext as j}from"../graphics/ElevationContext.js";import{createContextWithoutExpressionSupport as L,extractExpressionInfo as A}from"../graphics/featureExpressionInfoUtils.js";import{LodMetric as y}from"./I3SNode.js";import{isValidMbs as w,intersectBoundingRectWithMbs as G,MbsIntersectResult as N}from"./I3SUtil.js";import{Obb as U,computeOffsetObb as z}from"../../support/orientedBoundingBox.js";const T=1e5;class q{constructor(e,t,i,s,n,r,o,a,c={}){this._indexSR=e,this._renderCoordsHelper=t,this._clippingArea=n,this._elevationProvider=r,this._viewingMode=o,this._options=c,this._frustum=M(),this._frustumMbs=f(),this._useFrustumCulling=!1,this._poi=_(),this._elevationContext=null,this.minDistance=1/0,this.maxDistance=0,this.maxLodLevel=2,this._tmpObb=new U,this._tmp1=_(),this._tmp2=_(),this._tmp3=_(),this._tmp0=_(),this._screenspaceErrorBias=c.screenspaceErrorBias||1,this._progressiveLoadFactor=c.progressiveLoadFactor||1,this.updateCamera(i,s);const l=this._renderCoordsHelper.spatialReference;this._renderSR=l,this._renderSRSphericalPCPF=R(l),this._isGlobalMode=l===this._renderSRSphericalPCPF,this.updateElevationInfo(a),this._tmpPoint=O(0,0,0,e),this._isECEFOBBInLocalMode=this._indexSR.isWGS84&&(l.isWebMercator||E(l)),this._indexSREllipsoidRadius=S(this._indexSR).radius,this._indexSRSphericalPCPF=R(e),this._projectorIndexSRToIndexSRSphericalPCPF=x(this._indexSR,this._indexSRSphericalPCPF)}updateElevationInfo(e){null!=e?(this._elevationContext=j.fromElevationInfo(e),this._elevationContext.updateFeatureExpressionInfoContext(L(A(e,!1)))):this._elevationContext=null}updateCamera(n,r){if(this._useFrustumCulling=r,r){I(n.viewMatrix,n.projectionMatrix,this._frustum,H);{const r=n.eye,o=k;e(o,n.viewForward);const a=W;t(a,H[4],r);const c=.5*i(a,a)/i(o,a),l=this._frustumMbs;s(l,r,o,c);const h=1+c;l[3]=h}}this._screenSizeFactor=1/(n.perScreenPixelRatio/2),this._camPos=n.eye,this.minDistance=1/0,this.maxDistance=0}setPointOfInterest(e){this._poi=e}updateScreenSpaceErrorBias(e){const t=this._screenspaceErrorBias;return this._screenspaceErrorBias=e,t}updateClippingArea(e){this._clippingArea=e}expandElevationRange(e,t,i){if(null==this._elevationContext)return;const s=e.serviceMbsInIndexSR;if(!s)return;const n="relative-to-scene"===this._elevationContext.mode?"scene":"ground";if(this._elevationProvider.getSphereElevationBounds){const e=this._elevationProvider.getSphereElevationBounds(s,this._indexSR,n);return void(e&&i.expandElevationRange(e))}const r=s[0],o=s[1],a=s[2],c=this._elevationProvider.getElevation(r,o,a,this._indexSR,n);c&&i.expandElevationRangeValues(c,c);const l=t?null:this._elevationProvider.getRootElevationBounds?.();l&&i.expandElevationRange(l)}getServiceMbsInRenderSR(e){const t=e.serviceMbsInRenderSR;if(w(t))return t;e.serviceMbsInIndexSR&&v(t,e.serviceMbsInIndexSR);const i=e.elevationRangeMin;if(this._elevationContext&&Number.isFinite(i)){let s=0,n=0;const r=e.elevationRangeMax;switch(this._elevationContext.mode){case"relative-to-ground":s=this._elevationContext.geometryZWithOffset(t[2],this._renderCoordsHelper)+i-t[2],n=r-i;break;case"on-the-ground":s=i-t[2],n=r-i}t[2]+=s+.5*n,t[3]+=.5*n}else this._elevationContext&&t[3]<T&&(this._tmpPoint.x=t[0],this._tmpPoint.y=t[1],this._tmpPoint.z=t[2],t[2]=V(this._tmpPoint,this._elevationProvider,this._elevationContext,this._renderCoordsHelper));return b(t,this._indexSR,t,this._renderSR),t}getAndUpdateVisibilityObbInRenderSR(e){{const t=e.visibilityObbInRenderSR;if(t)return t}const t=.01*this._indexSREllipsoidRadius,{serviceMbsInIndexSR:i,serviceObbInIndexSR:s}=e;if(null==s||!i||!s.isValid||this._isECEFOBBInLocalMode&&(s.halfSizeX>t||s.halfSizeY>t||s.halfSizeZ>t))return null;{let t=e.serviceObbInRenderSR;if(null==t)t=new U,e.serviceObbInRenderSR=t;else if(t.isValid)return t;const n=i[3];let r=0,o=0;const a=s.centerZ,c=this._renderCoordsHelper,l=this._elevationContext;if(l&&e.elevationRangeValid){const t=e.elevationRangeMin,i=e.elevationRangeMax;switch(l.mode){case"relative-to-ground":r=l.geometryZWithOffset(a,c)+t-a,o=i-t;break;case"on-the-ground":r=t-a,o=i-t}}else if(l&&n<T){const e=this._tmpPoint;e.x=s.centerX,e.y=s.centerY,e.z=a,r=V(e,this._elevationProvider,l,c)-a}const h=o>0,d=h?this._tmpObb:t;return s.transform(d,this._indexSR,this._renderSR,r,this._renderSRSphericalPCPF,this._indexSRSphericalPCPF,this._projectorIndexSRToIndexSRSphericalPCPF),h&&z(d,0,o,this._viewingMode,t),t}}getNodeObbInRenderSRIndependentOfElevationOffset(e){{const t=e.visibilityObbInRenderSR??e.serviceObbInRenderSR??null;if(t?.isValid)return t}const t=e.serviceObbInIndexSR;return t?(t.transform(X,this._indexSR,this._renderSR,void 0,this._renderSRSphericalPCPF,this._indexSRSphericalPCPF,this._projectorIndexSRToIndexSRSphericalPCPF),X):null}ensureElevationAgnosticBoundingVolume(e,t){-1===e.elevationAgnosticBoundingVolume[3]&&(t===B.Global?this._updateElevationAgnosticBoundingVolumeGlobal(e):this._updateElevationAgnosticBoundingVolumeLocal(e))}_updateElevationAgnosticBoundingVolumeGlobal(t){const s=this.getNodeObbInRenderSRIndependentOfElevationOffset(t),o=t.elevationAgnosticBoundingVolume,a=Y;let c=-1;if(s){s.getCenter(a),e(a,a),s.getCorners(J);for(const t of J){e(t,t);const s=i(t,a);if(s<=0)return void(o[3]=-1);const n=Math.sqrt(1-s*s);c=Math.max(c,n)}}else{const i=t.serviceMbsInRenderSR;if(!w(i))return void(o[3]=-1);{const t=n(Y,D(i)),s=i[3],o=r(t);c=0===s?0:o<s?-1:s/o,e(t,t)}}g(o,a);const l=.001;o[3]=c+l}_updateElevationAgnosticBoundingVolumeLocal(e){const t=e.elevationAgnosticBoundingVolume,i=this.getNodeObbInRenderSRIndependentOfElevationOffset(e);if(i){const e=i.getCenter(Y);e[2]=0,g(t,e);let s=0;const n=K;i.getCorners(J);for(const t of J){t[2]=0;const e=o(n,t);s=Math.max(s,e)}t[3]=Math.sqrt(s)}else{const i=e.serviceMbsInRenderSR;if(w(i)){const e=n(Y,D(i));e[2]=0,g(t,e),t[3]=i[3]}}}isNodeVisible(e){const t=this.getServiceMbsInRenderSR(e);if(!this._isMBSinClippingArea(t))return!1;if(!this._useFrustumCulling)return!0;const i=this.getAndUpdateVisibilityObbInRenderSR(e);return i?i.isVisible(this._frustum):C(this._frustum,F(t))}isElevationAgnosticBoundingVolumeVisible(e,t){return!this._useFrustumCulling||(-1===t[3]||(e===B.Global?this._isConeVisibleInFrustum(t):this._isCylinderVisibleInFrustum(t)))}_isConeVisibleInFrustum(e){const t=this._frustumMbs,s=t,n=r(s),o=t[3],l=e,h=i(l,s),d=e[3];if(d>.9)return!0;if(n<=o)return!0;{const e=a(Z,l,h);if(c(e,s)<o)return!0}const u=h/n;if(h<=0){return-u<o}const m=Math.sqrt(1-u*u);if(m<d)return!0;const p=o/n;return m*Math.sqrt(1-p*p)-p*u<d}_isCylinderVisibleInFrustum(e){const t=this._frustumMbs,i=t,s=t[3],r=n(Z,i);r[2]=0;const o=e[3];return c(r,e)<=o+s}isGeometryVisible(e){if(!this._useFrustumCulling)return!0;const t=e.geometryObbInRenderSR;return t?.isVisible(this._frustum)??this.isNodeVisible(e)}_isMBSinClippingArea(e){return null==this._clippingArea||G(this._clippingArea,e)!==N.OUTSIDE}_screenSpaceDiameterMbs(e,t){const i=this.getServiceMbsInRenderSR(e),s=Math.sqrt(l(D(i),this._camPos)),n=s-i[3];return this._updateMinMaxDistance(s),n<0?.5*Number.MAX_VALUE:t/n*this._screenSizeFactor}calcCameraDistance(e){return this.calcCameraDistanceToCenter(e)-this.getServiceMbsInRenderSR(e)[3]}calcCameraDistanceToCenter(e){const t=this.getServiceMbsInRenderSR(e),i=h(D(t),this._camPos);return this._updateMinMaxDistance(i),i}calcAngleDependentLoD(e){const t=this.getServiceMbsInRenderSR(e),i=t[3],s=(Math.abs(t[0]*(t[0]-this._camPos[0])+t[1]*(t[1]-this._camPos[1])+t[2]*(t[2]-this._camPos[2]))/d(D(t))+i)/h(D(t),this._camPos);return Math.min(1,s)}hasLOD(e){return e.lodMetric!==y.None}_getDistancePlanarMode(e,t){const i=e[0]-t[0],s=e[1]-t[1],n=e[2]-t[2],r=i*i+s*s,o=t[3];if(r<=o*o)return Math.abs(n);const a=Math.sqrt(r)-o;return Math.sqrt(n*n+a*a)}_getDistanceGlobeMode(e,t){const s=d(D(t)),n=d(e)-s;a(this._tmp0,e,i(e,D(t))/u(e));const r=l(D(t),this._tmp0),o=t[3];if(r<=o*o)return Math.abs(n);{const r=a(this._tmp0,D(t),1/s),c=s,l=o*o/2/c,u=a(this._tmp1,r,c-l),_=e,v=m(this._tmp2,_,u),g=m(this._tmp2,v,a(this._tmp3,r,i(r,v))),f=p(this._tmp2,u,a(this._tmp2,g,o/d(g)));let S=h(_,f);if(n>=2e5){const e=m(this._tmp1,_,f);let t=i(e,r)/d(e);t<.08&&(t=1e-4),S/=t}return S}}_getDistance(e,t){return this._isGlobalMode?this._getDistanceGlobeMode(e,t):this._getDistancePlanarMode(e,t)}_updateMinMaxDistance(e){e>0?(this.minDistance=Math.min(this.minDistance,e),this.maxDistance=Math.max(this.maxDistance,e)):(this.minDistance=0,this.maxDistance=Math.max(this.maxDistance,-e))}getLodLevel(e){if(e.lodMetric===y.None)return 0;if(0===e.childCount)return this.maxLodLevel;if(this._useFrustumCulling&&this._progressiveLoadFactor<1){const t=this._progressiveLoadFactor*this._screenspaceErrorBias,i=this._screenspaceErrorBias;return this.evaluateLODmetric(e,t)?this.evaluateLODmetric(e,i)?2:1:0}return this.evaluateLODmetric(e,this._screenspaceErrorBias)?this.maxLodLevel:0}evaluateLODmetric(e,t){switch(e.lodMetric){case y.ScreenSpaceRelative:{const i=this.getServiceMbsInRenderSR(e),s=this._getDistance(this._camPos,i),n=2*s/this._screenSizeFactor,r=s+i[3];return this._updateMinMaxDistance(r),e.maxError*t<=n}case y.MaxScreenThreshold:{let i=this._screenSpaceDiameterMbs(e,e.serviceMbsInIndexSR[3]*t);return this._options.angleDependentLoD&&(i*=this.calcAngleDependentLoD(e)),i<e.maxError}case y.RemovedFeatureDiameter:return this._screenSpaceDiameterMbs(e,e.maxError)*t<10;case y.DistanceRangeFromDefaultCamera:return this.calcCameraDistance(e)>e.maxError*t}return!1}distToPOI(e){const t=this.getServiceMbsInRenderSR(e);return h(D(t),this._poi)-t[3]}distCameraToPOI(){return h(this._camPos,this._poi)}}const k=_(),H=P(),W=_(),Z=_(),X=new U,Y=_(),J=[_(),_(),_(),_(),_(),_(),_(),_()],K=_();export{q as default};
