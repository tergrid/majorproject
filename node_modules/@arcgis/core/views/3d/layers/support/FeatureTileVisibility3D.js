/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.29/esri/copyright.txt for details.
*/
import{acosClamped as e}from"../../../../core/mathUtils.js";import t from"../../../../core/ObjectPool.js";import{f as s,h as r,g as i,n,z as o,k as u,r as c,s as a,o as l,b as d,F as _,H as h}from"../../../../chunks/vec32.js";import{create as f,fromValues as m}from"../../../../core/libs/gl-matrix-2/factories/vec3f64.js";import{getReferenceEllipsoid as p}from"../../../../geometry/ellipsoidUtils.js";import{projectBuffer as T}from"../../../../geometry/projection/projectBuffer.js";import{projectVec3Array as F}from"../../../../geometry/projection/projectVec3Array.js";import{PlaneIndex as g,PointIndex as E}from"../../../../geometry/support/frustum.js";import{create as I,projectVector as R,fromPoints as A,getNormal as O,signedDistance as S}from"../../../../geometry/support/plane.js";import{wrap as b}from"../../../../geometry/support/ray.js";import{ViewingMode as P}from"../../../ViewingMode.js";import{FeatureTileDescriptor3D as B,Visibility as H}from"./FeatureTileDescriptor3D.js";import{Frustum as j}from"../../state/Frustum.js";import{FrustumExtentIntersection as x}from"../../support/FrustumExtentIntersection.js";class N{constructor(e){this._renderCoordsHelper=e,this._surfaceElevation=0,this._cache=new Map,this._frustumBoundingSphereCenter=f(),this._frustumBoundingSphereRadius=0,this._frustum=new j(e),this._extendedFrustum=new j(e),this._intersector=new x({renderCoordsHelper:e}),this._renderCoordsHelper=e}begin(e,t){this._surfaceElevation=t,this._aboveGround=this._renderCoordsHelper.getAltitude(e.eye)>t,this._frustum.update(e),this._shortenFrustumFarPlane(this._frustum),this._updateExtendedFrustum(e),this._updateFrustumBoundingSphere()}end(){this._cache.clear()}calculate(e){const t=this._renderCoordsHelper.viewingMode===P.Global&&e.lij[0]>=V&&e.lij[0]<G,s=this._getOrCalculateSingleTileVisibility(e,!t);return s!==H.INVISIBLE&&t?this._calculateAggregatedChildrenVisibility(e):s}_shortenFrustumFarPlane(e){const t=j.nearFarLineIndices,n=e.mutablePoints;for(const o of t){const[e,t]=o,u=n[e],c=n[t];s(v,c,u),r(v,v,C),i(n[t],u,v)}e.updatePoints(n)}_calculateAggregatedChildrenVisibility(e){let t=H.INVISIBLE;const s=this._cache.get(e.id);if(null!=s)return s;const r=U.acquire();e.getChildren(r);for(const i of r){const e=this.calculate(i);if(e!==H.INVISIBLE&&(t=e,e===H.VISIBLE_ON_SURFACE))break}return U.release(r),this._cache.set(e.id,t),t}_getOrCalculateSingleTileVisibility(e,t){const s=this._cache.get(e.id);if(null!=s)return s;const r=this._calculateSingleTileVisibility(e);return t&&this._cache.set(e.id,r),r}_calculateSingleTileVisibility(e){if(!this._aboveGround&&this._renderCoordsHelper.viewingMode===P.Global&&e.lij[0]<M){return this._calculateSingleTileVisibilitySided(e,!1)===H.INVISIBLE?this._calculateSingleTileVisibilitySided(e,!0):void 0}return this._calculateSingleTileVisibilitySided(e,this._aboveGround)}_isTileVisibleInFrustum(e){return this._renderCoordsHelper.viewingMode===P.Local?this._isTileVisibleInFrustumLocal(e):this._isTileVisibleInFrustumGlobal(e)}_updateFrustumBoundingSphere(){const e=this._frustum,t=e.origin,s=ce;n(s,e.direction);const r=e.points,i=ae;o(i,r[4],t);const a=.5*u(i,i)/u(s,i),l=this._frustumBoundingSphereCenter;c(l,t,s,a);const d=1+a;this._frustumBoundingSphereRadius=d}_isTileVisibleInFrustumLocal(e){const t=e.tilingScheme.spatialReference,s=e.extent,r=this._renderCoordsHelper.spatialReference,i=Q;if(i[0]=s[0],i[1]=s[1],i[2]=0,i[3]=s[2],i[4]=s[3],i[5]=0,!T(i,t,0,i,r,0,2))return!1;const n=Z;a(n[0],i[0],i[1],0),a(n[1],i[3],i[1],0),a(n[2],i[3],i[4],0),a(n[3],i[0],i[4],0);const d=$;a(d,.5*(i[0]+i[3]),.5*(i[1]+i[4]),.5*(i[2]+i[5]));const _=ee;a(_,0,0,1);const h=.5*l(n[0],n[2]),f=this._frustum,m=this._frustumBoundingSphereRadius,p=this._frustumBoundingSphereCenter,F=de;o(F,p,d);const g=u(_,F),E=le;c(E,d,_,g);if(l(E,p)>h+m)return!1;const I=K,R=g+m,A=g-m;for(let o=0;o<4;++o)c(I[o],n[o],_,R),c(I[o+4],n[o],_,A);return!X(f.planes,I,8)}_isTileVisibleInFrustumGlobal(e){const t=e.tilingScheme.spatialReference,s=e.extent,_=this._renderCoordsHelper.spatialReference;if(e.lij[0]<Y)return!0;const h=Z,f=.5*(s[0]+s[2]);if(a(h[0],s[0],s[1],0),a(h[1],s[2],s[1],0),a(h[2],s[2],s[3],0),a(h[3],s[0],s[3],0),a(h[4],f,s[1],0),a(h[5],f,s[3],0),!F(h,t,0,h,_,0,6))return!1;const T=h[0][2]>0,g=h[3][2]<0,E=T||g,I=p(_).radius;if(E){const e=m(0,0,1),t=se;W(t,e,h[0]);const s=re;if(W(s,e,h[1]),T){const r=te,i=h[4],n=ie;W(n,i,e),W(r,n,i);const o=h[0];d(o,t,r),z(o,I);const u=h[1];d(u,s,r),z(u,I)}else if(g){const r=te,i=h[5],n=ie;W(n,i,e),W(r,i,n);const o=h[3];d(o,r,t),z(o,I);const u=h[2];d(u,r,s),z(u,I)}}const R=$;{const e=pe;o(e,h[3],h[0]),n(e,e);const t=Te;i(t,h[0],h[3]),r(t,t,.5);const s=-u(t,e),a=Fe,l=ge;i(a,h[0],h[1]),r(a,a,.5),i(l,h[2],h[3]),r(l,l,.5);const d=Ee;o(d,l,a),n(d,d);const _=-(s+u(e,a))/u(e,d);c(R,a,d,_),z(R,I)}const A=this._frustumBoundingSphereRadius,O=this._frustumBoundingSphereCenter,S=this._frustum,b=S.planes;if(h.some((e=>S.intersectsPoint(e))))return!0;if(S.intersectsPoint(R))return!0;const P=ne;n(P,R);const B=he;o(B,O,_e);const H=u(B,P);if(H<-A)return!1;const j=ue;n(j,h[0]);const x=u(j,P);if(x<=0)return!0;const N=oe;r(N,P,H);const V=l(N,O),G=t.isWGS84,M=e.lij,C=G&&M[2]===2**M[0]-1,L=G&&0===M[2],v=L?je:C?Be:be,y=L?xe:C?He:Pe,w=S.points;{const e=h,t=Ne,s=Ie,r=Re,i=_e;for(const n of v){const o=e[n];if(k(s,e[(n+1)%4],o),k(r,i,o),W(t,r,s),J(t,w,1))return!1}}let U=null;if(H<2*A){const e=2.5*A;if(V>x*e+A)return!1;const t=me,s=e/x;for(let i=0;i<4;++i)r(t[i],h[i],s/I);a(t[4],0,0,0),U=t}else{const e=(H+A)/x,t=(H-A)/x,s=fe;for(let i=0;i<4;++i){const n=h[i];r(s[i+4],n,t/I),r(s[i],n,e/I)}U=s}if(X(b,U,U.length))return!1;const D=S.lines,q=Ae,K=Oe;for(const r of y){n(q,h[r]);for(const e of D)if(n(K,e.direction),Ce(K,q,U,w))return!1}return!0}_calculateSingleTileVisibilitySided(e,t){if(this._isTileVisibleInFrustum(e)){this._intersector.update(e.extent,e.tilingScheme.spatialReference,this._surfaceElevation,t);const s=p(e.tilingScheme.spatialReference).radius;return this._intersector.isVisibleInFrustum(this._frustum,s,!0)?H.VISIBLE_ON_SURFACE:H.VISIBLE_WHEN_EXTENDED}return H.INVISIBLE}_updateExtendedFrustum(t){this._extendedFrustum.update(t),this._shortenFrustumFarPlane(this._extendedFrustum);const s=this._renderCoordsHelper.worldUpAtPosition(t.eye,v);this._aboveGround||_(s,s);const i=e(-u(s,t.viewForward));if(this._hasExtendedFrustum=i>t.fovY/2,!this._hasExtendedFrustum)return;const n=this._extendedFrustumParameters(),o=this._extendedFrustum.mutablePoints;for(let e=0;e<4;e++){const t=n.pointIndices[e],s=o[t],i=this._renderCoordsHelper.getAltitude(s);if(n.needsAltitudeAdjustment(i)){switch(this._renderCoordsHelper.worldUpAtPosition(s,v),t){case E.FAR_BOTTOM_LEFT:case E.FAR_TOP_LEFT:case E.NEAR_BOTTOM_LEFT:case E.NEAR_TOP_LEFT:R(this._extendedFrustum.planes[g.LEFT],v,v);break;case E.FAR_BOTTOM_RIGHT:case E.FAR_TOP_RIGHT:case E.NEAR_BOTTOM_RIGHT:case E.NEAR_TOP_RIGHT:R(this._extendedFrustum.planes[g.RIGHT],v,v)}r(v,v,n.direction),this._renderCoordsHelper.intersectInfiniteManifold(b(s,v),n.zWithMargin,s)}}if(this._extendedFrustum.updatePoints(o),A(o[E.NEAR_BOTTOM_LEFT],o[E.NEAR_BOTTOM_RIGHT],o[E.NEAR_TOP_RIGHT],y),A(o[E.NEAR_BOTTOM_RIGHT],o[E.NEAR_TOP_RIGHT],o[E.NEAR_TOP_LEFT],w),u(O(y),O(w))<0){const e=this._extendedFrustum.mutablePoints;this._aboveGround?[e[E.NEAR_BOTTOM_LEFT],e[E.NEAR_BOTTOM_RIGHT]]=[e[E.NEAR_BOTTOM_RIGHT],e[E.NEAR_BOTTOM_LEFT]]:[e[E.NEAR_TOP_LEFT],e[E.NEAR_TOP_RIGHT]]=[e[E.NEAR_TOP_RIGHT],e[E.NEAR_TOP_LEFT]],this._extendedFrustum.updatePoints(e)}}_extendedFrustumParameters(){return this._aboveGround?this._extendedFrustumParametersAboveSurface():this._extendedFrustumParametersBelowSurface()}_extendedFrustumParametersAboveSurface(){const e=this._surfaceElevation-L;return{zWithMargin:e,pointIndices:j.planePointIndices.bottom,direction:-1,needsAltitudeAdjustment:t=>t>e}}_extendedFrustumParametersBelowSurface(){const e=this._surfaceElevation+L;return{zWithMargin:e,pointIndices:j.planePointIndices.top,direction:1,needsAltitudeAdjustment:t=>t<e}}}const V=2,G=6,M=12,C=.95,L=1,v=f(),y=I(),w=I(),U=new t(Array,(e=>{4!==e.length&&(e[0]=new B,e[1]=new B,e[2]=new B,e[3]=new B)}),(e=>{e[0].release(),e[1].release(),e[2].release(),e[3].release()}));function W(e,t,s){return d(e,t,s),n(e,e),e}function k(e,t,s){return o(e,t,s),n(e,e),e}function z(e,t){return r(e,e,t/h(e)),e}const D=[g.LEFT,g.RIGHT,g.BOTTOM,g.TOP,g.FAR];function q(e,t,s){for(let r=0;r<s;++r)if(S(e,t[r])<0)return!1;return!0}function X(e,t,s){for(const r of D)if(q(e[r],t,s))return!0;return!1}const Y=3;function J(e,t,s){for(const r of t)if(u(r,e)<s)return!1;return!0}const K=[f(),f(),f(),f(),f(),f(),f(),f()],Q=[0,0,0,0,0,0],Z=[f(),f(),f(),f(),f(),f()],$=f(),ee=f(),te=f(),se=f(),re=f(),ie=f(),ne=f(),oe=f(),ue=f(),ce=f(),ae=f(),le=f(),de=f(),_e=m(0,0,0),he=f(),fe=[f(),f(),f(),f(),f(),f(),f(),f()],me=[f(),f(),f(),f(),f()],pe=f(),Te=f(),Fe=f(),ge=f(),Ee=f(),Ie=f(),Re=f(),Ae=f(),Oe=f(),Se=f(),be=[0,1,2,3],Pe=[0,1,2,3],Be=[0,1,3],He=[0,1,3],je=[1,2,3],xe=[1,2,3],Ne=f();function Ve(e,t,s){let r=1/0,i=-1/0;for(const n of s){const e=u(t,n);r=Math.min(r,e),i=Math.max(i,e)}e[0]=r,e[1]=i}function Ge(e,t,s,r){let i=1/0,n=-1/0;for(const o of r){const r=u(s,o);if(i=Math.min(i,r),n=Math.max(n,r),i<=t&&n>=e)return!1}return!0}const Me=[0,0];function Ce(e,t,s,r){const i=Se;W(i,e,t);const n=Me;return Ve(n,i,s),Ge(n[0],n[1],i,r)}export{N as FeatureTileVisibility3D,Y as globalTileLevelThreshold,X as isConvexHullOutsideOfFrustum};
