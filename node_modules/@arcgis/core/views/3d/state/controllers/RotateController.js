/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.29/esri/copyright.txt for details.
*/
import{_ as t}from"../../../../chunks/tslib.es6.js";import{acosClamped as i,clamp as s}from"../../../../core/mathUtils.js";import{createScreenPointArray as r}from"../../../../core/screenUtils.js";import{property as o}from"../../../../core/accessorSupport/decorators/property.js";import"../../../../core/has.js";import"../../../../core/Logger.js";import"../../../../core/RandomLCG.js";import{subclass as e}from"../../../../core/accessorSupport/decorators/subclass.js";import{fromRotation as a,rotate as n}from"../../../../core/libs/gl-matrix-2/math/mat4.js";import{create as p}from"../../../../core/libs/gl-matrix-2/factories/mat4f64.js";import{copy as h}from"../../../../core/libs/gl-matrix-2/math/vec2.js";import{create as m}from"../../../../core/libs/gl-matrix-2/factories/vec2f64.js";import{c,f as l,l as _,k as v,n as f,g as C,h as P,b as u,e as w}from"../../../../chunks/vec32.js";import{create as E}from"../../../../core/libs/gl-matrix-2/factories/vec3f64.js";import{getReferenceEllipsoid as d}from"../../../../geometry/ellipsoidUtils.js";import{applyAll as R}from"../../camera/constraintUtils.js";import{ConstraintOptions as j}from"../../camera/constraintUtils/ConstraintOptions.js";import{ConstraintTypes as T}from"../../camera/constraintUtils/ConstraintTypes.js";import{InteractionType as y}from"../../camera/constraintUtils/InteractionType.js";import{TiltMode as U}from"../../camera/constraintUtils/TiltMode.js";import{getVoxelWasm as g}from"../../layers/VoxelWasm.js";import{TiltRange as x}from"../Constraints.js";import{InteractiveController as M}from"./InteractiveController.js";import{contentIntersectorOptions as O,normalizeCoordinate as b,rotatePivotDistanceModifier as D,rotatePivotMinDistanceModifier as A,decideNavigationMode as N,rotateScreenPixelArea as L,NavigationMode as V}from"../utils/navigationUtils.js";var k;!function(t){t[t.CENTER=0]="CENTER",t[t.EYE=1]="EYE"}(k||(k={}));let H=class extends M{get _intersectionHelper(){return this.view.sceneIntersectionHelper}constructor(t){super(t),this.pivot=k.CENTER,this._rotScale=0,this._lastPoint=m(),this._tmpWorldUp=E(),this._tmpViewDir=E(),this._tmpRotCurPoint=m(),this._tmpTransf=p(),this._tmpAxis=E(),this._tmpPivotPoint=E(),this._pivotPos=E(),this._constraintOptions=new j(T.ALL,y.TUMBLE,0,this.startCamera)}initialize(){this._rotScale=this.pivot===k.CENTER?3:1.5}begin(t){if(this.active){switch(this.pivot){case k.EYE:c(this._pivotPos,this.startCamera.eye),this._constraintOptions.interactionType=y.LOOK_AROUND,this._constraintOptions.tiltMode=U.LOOK_AROUND,this._constraintOptions.selection=T.NONE;break;case k.CENTER:{const i=this._intersectionHelper.intersectRayFreePointFallback(this.startCamera.ray,this._pivotPos,0===this.view.map.ground.opacity?O:{});i||c(this._pivotPos,this.startCamera.center),this._constrainPivotPoint(t,i),this.startCamera.center=this._pivotPos,this._constraintOptions.interactionType=y.TUMBLE,this._constraintOptions.tiltMode=U.TUMBLE,this._constraintOptions.selection=T.ALL&~T.DISTANCE;break}}b(this.startCamera,t,this._lastPoint)}}_constrainPivotPoint(t,i){const s=this.startCamera,o=E();l(o,this._pivotPos,s.eye);const e=_(o),a=Math.abs(this.view.camera.position.z);this.view.renderCoordsHelper.worldUpAtPosition(s.eye,I);let n=Math.max(Math.min(D,1/Math.abs(v(I,s.viewForward)))*a,A);i&&(n=Math.min(e,n));const p=d(this.view.spatialReference),h=r(s.width/s.pixelRatio*.5,s.height/s.pixelRatio*.5),m=N(this.startCamera,h,p);let u=this.view._stage.renderView.getMinimalDepthForArea(g(this.view),s.fullWidth/s.pixelRatio*.5,s.fullHeight/s.pixelRatio*.5,s,2.5*L,L),w=this.view._stage.renderView.getMinimalDepthForArea(g(this.view),t[0],t[1],s,L);null==u&&null==w||(u=u??w??0,w=null==w||m===V.Horizontal?u:w,n=u>w?w:u,n=i?Math.min(n,e):n),f(o,o),c(this._pivotPos,C(this._tmpPivotPoint,s.eye,P(this._tmpPivotPoint,o,n)))}update(t){if(this.active){switch(this.pivot){case k.EYE:this.currentCamera.center=this._applyRotation(this.currentCamera,t,this.currentCamera.center,this._pivotPos);break;case k.CENTER:this.currentCamera.center=this._pivotPos,this.currentCamera.eye=this._applyRotation(this.currentCamera,t,this.currentCamera.eye,this._pivotPos)}R(this.view,this.currentCamera,this._constraintOptions),this.commitCamera()}}end(){this.active&&this.finishController()}_applyRotation(t,r,o,e){this.view.renderCoordsHelper.worldUpAtPosition(e,this._tmpWorldUp),b(t,r,this._tmpRotCurPoint);let p=(this._lastPoint[1]-this._tmpRotCurPoint[1])*this._rotScale,m=(this._tmpRotCurPoint[0]-this._lastPoint[0])*this._rotScale;l(this._tmpViewDir,o,e);const c=_(this._tmpViewDir),f=i(v(this._tmpViewDir,this._tmpWorldUp)/c);if(this.pivot===k.EYE){p*=-.5;const t=.5*Math.PI-f,i=.5*Math.PI*.99;p=t-Math.max(-i,Math.min(i,t+p))}return p=s(p+f,x.min,x.max)-f,u(this._tmpAxis,t.up,this._tmpViewDir),this.pivot===k.CENTER&&(m=-m),a(this._tmpTransf,m,this._tmpWorldUp),n(this._tmpTransf,this._tmpTransf,p,this._tmpAxis),w(this._tmpViewDir,this._tmpViewDir,this._tmpTransf),t.up=w(S,t.up,this._tmpTransf),C(S,e,this._tmpViewDir),h(this._lastPoint,this._tmpRotCurPoint),S}};t([o()],H.prototype,"pivot",void 0),H=t([e("esri.views.3d.state.controllers.RotateController")],H);const S=E(),I=E();export{k as PivotPoint,H as RotateController};
