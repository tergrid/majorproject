/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.29/esri/copyright.txt for details.
*/
import{_ as t}from"../../../../../chunks/tslib.es6.js";import{clamp as i}from"../../../../../core/mathUtils.js";import{Milliseconds as e}from"../../../../../core/time.js";import"../../../../../core/Logger.js";import"../../../../../core/has.js";import"../../../../../core/RandomLCG.js";import"../../../../../core/Error.js";import{subclass as r}from"../../../../../core/accessorSupport/decorators/subclass.js";import{c as s,n as o,h as a,k as n,l as m,f as h,g as c,a as p}from"../../../../../chunks/vec32.js";import{create as _}from"../../../../../core/libs/gl-matrix-2/factories/vec3f64.js";import{getReferenceEllipsoid as l}from"../../../../../geometry/ellipsoidUtils.js";import{c as y}from"../../../../../chunks/sphere.js";import{applyAll as f}from"../../../camera/constraintUtils.js";import{ConstraintOptions as g}from"../../../camera/constraintUtils/ConstraintOptions.js";import{ConstraintTypes as w}from"../../../camera/constraintUtils/ConstraintTypes.js";import{InteractionType as C}from"../../../camera/constraintUtils/InteractionType.js";import{applySurfaceCollisionConstraint as d}from"../../../camera/constraintUtils/surfaceCollision.js";import{PointToPointAnimationController as j}from"../PointToPointAnimationController.js";import{contentIntersectorOptions as u,decideNavigationMode as D,zoomMaxDistanceModifier as b,zoomMinDistanceModifier as v,zoomDistanceModifier as R,NavigationMode as L,panToPosition as M}from"../../utils/navigationUtils.js";import{fromScreenAtEye as z}from"../../../support/geometryUtils/ray.js";import{intersectScreen as O}from"../../../support/geometryUtils/sphere.js";import{Camera as U}from"../../../webgl-engine/lib/Camera.js";import{newIntersector as S}from"../../../webgl-engine/lib/Intersector.js";import{outExpo as V}from"../../../../animation/easing.js";const k=.6,x=4,A=60;let F=class extends j{constructor(){super(...arguments),this._zoomLocation=_(),this._tmpCamera=new U,this._tmpViewDir=_(),this._tmpRayDir={origin:_(),direction:_()},this._targetOnSphere=_(),this._tmpCenter=_(),this._beginCamera=new U,this._constraintOptions=new g(w.ALL_EXCEPT_COLLISION,C.ZOOM,null,this._beginCamera),this._sphere=y()}initialize(){this._intersector=S(this.view.state.viewingMode)}zoomStep(t,i){if(!this.active)return;const e=this.view.state;this.animation.finished?this._beginCamera.copyFrom(e.camera):this.animation.cameraAt(1,this._beginCamera);let r=!1,o=!1;this.intersectionHelper.intersectScreen(i,this._zoomLocation,0===this.view.map.ground.opacity?u:{})&&(r=t>0,o=!0),this._tmpCamera.copyFrom(e.camera),r?this.intersectionHelper.intersectRay(this._tmpCamera.ray,this._intersector,this._tmpCenter)&&(this._tmpCamera.center=this._tmpCenter):this.intersectionHelper.intersectRay(this._tmpCamera.ray,this._intersector,this._zoomLocation)?this._tmpCamera.center=this._zoomLocation:s(this._zoomLocation,this._tmpCamera.center),this._updateCamera(this._tmpCamera,t,this._zoomLocation,i,o),this.begin(this._tmpCamera)}animationSettings(){return{duration:e(600),easing:V}}_updateCamera(t,e,r,s,_){const y=l(this.view.spatialReference),g=D(t,s,y),w=Math.abs(this.view.camera.position.z);o(I,t.eye),a(I,I,-1),z(t,s,this._tmpRayDir),o(this._tmpRayDir.direction,this._tmpRayDir.direction);const C=i(Math.min(R,1/Math.abs(n(I,this._tmpRayDir.direction)))*w,v,b);if(g===L.Horizontal){let i=k**e;this._sphere[3]=m(r),h(this._tmpViewDir,t.center,t.eye);const o=Math.min(m(this._tmpViewDir),C);let n=o*i;if(i<=1&&n<x&&(n=x,i=n/o),Math.abs(o-n)<1e-6)return;const _=m(t.center);if(this._sphere[3]!==_){const e=this._sphere[3]+i*(_-this._sphere[3]);t.center=a(H,t.center,e/_)}a(this._tmpViewDir,this._tmpViewDir,-i),t.eye=c(H,t.center,this._tmpViewDir),f(this.view,t,this._constraintOptions),p(r,t.center)>1e-12&&O(this._sphere,t,s,this._targetOnSphere)&&M(this._sphere,t,r,this._targetOnSphere,this.view.camera.heading,this.view.camera.tilt,!0)}else{let i=k**Math.abs(e);const o=e>0?1:-1;h(this._tmpViewDir,r,t.eye);const n=m(this._tmpViewDir),p=this.view._stage.renderView.getMinimalDepthForArea(null,s[0],s[1],this.view.state.camera,A);let l=null!=p?p:C;l=_&&e>0?Math.min(l,n):l,a(this._tmpRayDir.direction,this._tmpRayDir.direction,l),c(r,this._tmpRayDir.origin,this._tmpRayDir.direction);let y=l*i;const f=Math.max(x,1.01*t.nearFar[0]);if(e>0&&y<f&&(y=f,i=y/l),Math.abs(l-y)<1e-6)return;a(this._tmpRayDir.direction,this._tmpRayDir.direction,o*(1-i)),t.eye=c(H,t.eye,this._tmpRayDir.direction),t.center=c(H,t.center,this._tmpRayDir.direction)}d(this.view,t)}};F=t([r("esri.views.3d.state.controllers.global.ZoomStepController")],F);const H=_(),I=_();export{F as ZoomStepController};
