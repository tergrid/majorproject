/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.29/esri/copyright.txt for details.
*/
import{_ as t}from"../../../../../chunks/tslib.es6.js";import{asinClamped as i}from"../../../../../core/mathUtils.js";import{createScreenPointArray as e,screenPointObjectToArray as n}from"../../../../../core/screenUtils.js";import"../../../../../core/Logger.js";import"../../../../../core/has.js";import"../../../../../core/RandomLCG.js";import"../../../../../core/Error.js";import{subclass as o}from"../../../../../core/accessorSupport/decorators/subclass.js";import{distance as s}from"../../../../../core/libs/gl-matrix-2/math/vec2.js";import{F as a,c as r,k as m,f as h,l,n as c,h as p,g as _}from"../../../../../chunks/vec32.js";import{create as u,fromValues as d}from"../../../../../core/libs/gl-matrix-2/factories/vec3f64.js";import{wrapAxisAngle as g}from"../../../../../geometry/support/axisAngle.js";import{create as C,fromNormalAndOffset as v,setOffsetFromPoint as M,negate as b,getNormal as f}from"../../../../../geometry/support/plane.js";import{pixelDistanceToInteractionFactor as w,applyAll as j}from"../../../camera/constraintUtils.js";import{ConstraintOptions as E}from"../../../camera/constraintUtils/ConstraintOptions.js";import{ConstraintTypes as V}from"../../../camera/constraintUtils/ConstraintTypes.js";import{InteractionType as P}from"../../../camera/constraintUtils/InteractionType.js";import{ExponentialFalloff as z}from"../../../input/util.js";import{getVoxelWasm as H}from"../../../layers/VoxelWasm.js";import{InteractiveController as S}from"../InteractiveController.js";import{PanPlanarMomentumController as O}from"../momentum/PanPlanarMomentumController.js";import{RotationMomentumController as y}from"../momentum/RotationMomentumController.js";import{ZoomPlanarMomentumController as x}from"../momentum/ZoomPlanarMomentumController.js";import{NavigationMode as A,contentIntersectorOptions as F,panDistanceModifier as L,minHeightLimit as R,screenPixelArea as T,centroid as U,applyZoomToPoint as N,applyPanPlanar as D,normalizeRotationDelta as I,applyRotation as k,intersectPlaneFromScreenPointAtEye as G}from"../../utils/navigationUtils.js";import{Camera as Z}from"../../../webgl-engine/lib/Camera.js";import{PanPlanarMomentumEstimator as B}from"../../../../navigation/PanPlanarMomentumEstimator.js";import{RotationMomentumEstimator as W}from"../../../../navigation/RotationMomentumEstimator.js";import{ZoomMomentumEstimator as q}from"../../../../navigation/ZoomMomentumEstimator.js";const J=d(0,0,1),K={ELEVATION_THRESHOLD:3e4,ANGLE_THRESHOLD:16/180*Math.PI};let Q=class extends S{constructor(){super(...arguments),this._rotationValueSmooth=new z(.05),this._scalingValueSmooth=new z(.05),this._planeHorizontal=C(),this._planeVertical=C(),this._rotationMomentumEstimator=new W,this._panMomentumEstimator=new B(300,12,.9),this._zoomMomentumEstimator=new q,this._beginRadius=0,this._beginCenter=u(),this._beginAngle=0,this._tmpPoints=[],this._panMode=A.Horizontal,this._beginCenterScreen=e(),this._tmpCentroid3d=u(),this._tmpCentroid2d=e(),this._tmp2d=e(),this._pointerCount=0,this._beginCamera=new Z,this._constraintOptions=new E(V.ALL,P.NONE,0,this._beginCamera)}begin(t){if(!this.active)return;const e=this.view.navigation.momentumEnabled;this._zoomMomentumEstimator.enabled=e,this._rotationMomentumEstimator.enabled=e,this._panMomentumEstimator.enabled=e,this._beginRadius=t.radius,this._pointerCount=t.pointers.size,this._beginAngle=t.angle,this._rotationValueSmooth.reset(),this._scalingValueSmooth.reset(),n(t.center,this._beginCenterScreen),v(J,0,this._planeHorizontal);const o=u(),s=this._intersectionHelper.intersectScreenFreePointFallback(this._beginCenterScreen,o,0===this.view.map.ground.opacity?F:{}),d=u();a(d,this.startCamera.viewForward);const g=u();r(g,J);const C=m(d,g),w=i(C<0?-C:C);this._panMode=w>=K.ANGLE_THRESHOLD?A.Horizontal:A.Vertical;const j=Math.min(L,1/Math.abs(m(g,this.startCamera.viewForward)))*Math.max(Math.abs(this.view.camera.position.z),R);M(this._planeHorizontal,this._planeHorizontal,o),this.startCamera.aboveGround||b(this._planeHorizontal,this._planeHorizontal);const E=u(),V=u(),P=u();h(E,o,this.currentCamera.eye);const z=l(E);if(c(E,E),this._panMode===A.Vertical){p(g,g,C),h(f(this._planeVertical),d,g),c(f(this._planeVertical),f(this._planeVertical)),M(this._planeVertical,this._planeVertical,o);const i=this.view._stage.renderView.getMinimalDepthForArea(H(this.view),this._beginCenterScreen[0],this._beginCenterScreen[1],this.view.state.camera,T);let e=null!=i?i:j;e=s?Math.min(e,z):e,r(P,_(V,this.currentCamera.eye,p(V,E,e))),this._planeVertical[3]=-m(f(this._planeVertical),P),this._computePlanePoints(t.pointers,this._planeVertical,this.startCamera,this._tmpPoints),U(this._tmpPoints,this._beginCenter)}else{const i=s?z:j;r(P,_(V,this.currentCamera.eye,p(V,E,i))),this._planeHorizontal[3]=-m(f(this._planeHorizontal),P),this._computePlanePoints(t.pointers,this._planeHorizontal,this.startCamera,this._tmpPoints),U(this._tmpPoints,this._beginCenter)}this._beginCamera.copyFrom(this.startCamera)}update(t){if(!this.active)return;this.currentCamera.copyFrom(this.startCamera);const i=t.pointers.size>1,e=this._panMode===A.Horizontal?this._planeHorizontal:this._planeVertical,o=this._beginCenter;if(i){const i=this._beginRadius/t.radius,e=.001875*Math.min(Math.max(t.radius,40),120);this._scalingValueSmooth.gain=e,this._scalingValueSmooth.update(i),N(this.currentCamera,o,this._scalingValueSmooth.value,this.view.state.constraints.minimumPoiDistance),this._zoomMomentumEstimator.add(this._scalingValueSmooth.value,.001*t.timestamp),this._constraintOptions.interactionType=P.ZOOM,this._constraintOptions.interactionFactor=w(Math.abs(t.radius-this._beginRadius)),j(this.view,this.currentCamera,this._constraintOptions)}if(this._computePlanePoints(t.pointers,e,this.currentCamera,this._tmpPoints),U(this._tmpPoints,this._tmpCentroid3d),n(t.center,this._tmpCentroid2d),D(this.currentCamera,o,this._tmpCentroid3d),this._panMomentumEstimator.add(this._tmpCentroid2d,this._tmpCentroid3d,.001*t.timestamp),this._constraintOptions.interactionType=P.PAN,this._constraintOptions.interactionFactor=w(s(this._beginCenterScreen,this._tmpCentroid2d)),j(this.view,this.currentCamera,this._constraintOptions),i){const i=o,e=this._rotationValueSmooth.value,n=e+I(t.angle-e),s=.00125*Math.min(Math.max(t.radius,40),120);this._rotationValueSmooth.gain=s,this._rotationValueSmooth.update(n);const a=this._rotationValueSmooth.value-this._beginAngle;this._rotationMomentumEstimator.add(a,.001*t.timestamp);const r=f(this._planeHorizontal);k(this.currentCamera,i,g(r,a)),this._constraintOptions.interactionType=P.TUMBLE,this._constraintOptions.interactionFactor=w(Math.abs(t.radius*a)),j(this.view,this.currentCamera,this._constraintOptions)}this.commitCamera()}end(t){t.pointers.size===this._pointerCount&&this.update(t),this.finishController();const i=this._zoomMomentumEstimator.evaluateMomentum();if(i)return new x({view:this.view,momentum:i,zoomCenter:this._beginCenter});const e=this._rotationMomentumEstimator.evaluateMomentum();if(e)return new y({view:this.view,momentum:e,center:this._beginCenter,axis:f(this._planeHorizontal)});const n=this._panMomentumEstimator.evaluateMomentum();return n?new O({view:this.view,momentum:n}):null}_computePlanePoints(t,i,e,n){n.length=t.size;const o=this._tmp2d;let s=0;return t.forEach((t=>{o[0]=t.x,o[1]=t.y,void 0===n[s]&&(n[s]=u()),G(i,e,o,n[s]),s+=1})),n}get _intersectionHelper(){return this.view.sceneIntersectionHelper}};Q=t([o("esri.views.3d.state.controllers.local.PinchAndPanController")],Q);export{Q as PinchAndPanController};
