/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.29/esri/copyright.txt for details.
*/
import{disposeMaybe as e,releaseMaybe as t}from"../../../core/maybe.js";import{set as r,copy as s}from"../../../core/libs/gl-matrix-2/math/vec2.js";import{ZEROS as o}from"../../../core/libs/gl-matrix-2/factories/vec2f64.js";import{isBaseLayer as a,isGroupLayer as i}from"../../../layers/support/layerUtils.js";import{isImageWithType as n}from"../support/StreamDataLoader.js";import{BlendLayersPassParameters as c}from"./BlendLayersTechnique.js";import{TextureUpdate as u}from"./interfaces.js";import{NeighborIndex as l}from"./ITile.js";import{LayerClass as p}from"./LayerClass.js";import{isBlendableLayerView as h,isVectorTileLayerView as d,isVectorTileRenderInfo as m,isImageryTileRenderInfo as f,isRasterTileRenderInfo as _,isTextureTileRenderInfo as T,isVectorTilePerLayerInfo as y}from"./terrainUtils.js";import{ActivationTime as g}from"./TextureFader.js";import{TextureReference as b}from"./TextureReference.js";import{TileCompositor as x}from"./TileCompositor.js";import{TileRenderInfo as I}from"./TileRenderInfo.js";import w from"./TileTexture.js";import{TileUpdate as k}from"./TileUpdate.js";import{blendModeFromString as A}from"../webgl-engine/core/shaderLibrary/output/BlendOptions.js";import{BlendLayersOutput as P}from"../webgl-engine/core/shaderLibrary/terrain/TileBackground.glsl.js";import{createEmptyTexture as O}from"../webgl-engine/lib/glUtil3D.js";import{TextureSamplingMode as E,TextureWrapMode as M,PixelFormat as D}from"../../webgl/enums.js";import{Texture as L}from"../../webgl/Texture.js";import{TextureDescriptor as R}from"../../webgl/TextureDescriptor.js";class j{constructor(e,t,r,s,o,a){this.start=e,this.end=t,this.blendMode=r,this.opacity=s,this.output=o,this.baseOpacity=a}}class N{constructor(e,t,r,s){this._rctx=e,this.tileSize=t,this._techniques=r,this._cache=s,this._passParameters=new c,this._backgroundTexture=null,this._backgroundColor=null,this._backgroundDirty=!1,this._maxAnisotropy=this._rctx.parameters.maxMaxAnisotropy,this._composition=new x(this._rctx,this._techniques),this._ensureBackgroundTexture(this.tileSize)}dispose(){this._composition=e(this._composition),this._backgroundTexture=t(this._backgroundTexture)}get backgroundIsGrid(){return null==this._backgroundColor}get backgroundColor(){return this._backgroundColor}updateTileTexture(e,t){if(!e.renderData)return;const r=e.surface,s=r.baseOpacity;let o=0,n=0,c=this.tileSize,l=!1,m=!1;const f=r.view.state.contentPixelRatio;let _=!1;G.clear(),F.length=0;const T=e.layerInfo[p.MAP];let y=0,g=null;for(;y<T.length;y++){const t=r.layerViewByIndex(y,p.MAP),u=t.layer.opacity,b=t.fullOpacity;if(m=m||a(t.layer),h(t)){let e="normal"!==t.layer.blendMode;if(i(t.layer.parent)){const r=B(t.layer.parent);null!=r&&""!==r&&(e=S(t.layer.parent)||e)}e&&(_=e,l=!1)}if(0===u&&!_){T[y].pendingUpdates&=~(k.TEXTURE_NOFADING&k.TEXTURE_FADING);continue}++n;const x=d(t),I=C(e,y,x);if(I){if(T[y].pendingUpdates&=~(k.TEXTURE_NOFADING&k.TEXTURE_FADING),i(t.layer.parent)){const e=B(t.layer.parent);null!=e&&""!==e&&U(t.layer.parent,y)}x?c=Math.max(c,this.tileSize*f):1===s&&1===b&&(t.isOpaque||this._dataToTexture(I)&&I.sourceLayerInfo.data.descriptor.isOpaque)&&(l=!0),++o,null===g&&(g=y)}}const b=c/this.tileSize,x=this._ensureBackgroundTexture(this.tileSize);0!==o&&null!==g?1===o&&!_&&this._useLayerTexture(e,g)||this._composeMapLayers(e,t,y-1,m,c,b,!l||_,G,_):this._useBackgroundTexture(e,n,x,t!==u.FADING)}_ensureBackgroundTexture(e){return null==this._backgroundTexture&&(this._backgroundTexture=this._buildTexture(e,!1),this._backgroundDirty=!0),this._backgroundDirty&&(this._composition.bind(e),this._passParameters.offset=o,this._passParameters.scale=1,this._passParameters.opacity=1,this.backgroundColor&&(this._passParameters.backgroundColor=this.backgroundColor),this._composition.drawBackground(this._passParameters,null!=this.backgroundColor),this._composition.copyFBOToTexture(this._backgroundTexture),this._composition.unbind(),this._backgroundDirty=!1),this._backgroundTexture}_useBackgroundTexture(e,t,r,s){const o=e.renderData,a=!s&&null!=o.textureReference&&(e.surface.view.layerViewManager.updating||t>0)?g.Delayed:g.Immediate;o.setTextureReference(new b(r,u.FADING,v,e.surface.baseOpacity,0,1),a)}_useLayerTexture(e,t){const r=e.surface.layerViewByIndex(t,p.MAP),s=a(r.layer),o=s?e.surface.baseOpacity:1,i=s?1:e.surface.baseOpacity,n=r.fullOpacity,c=C(e,t,!1);return!!this._dataToTexture(c)&&(e.renderData.setTextureReference(new b(c.sourceLayerInfo.data,u.FADING,c,o,i,n)),!0)}_composeMapLayers(e,t,r,s,i,n,c,u,l){this._composition.ensureBuffer(i);const _=e.surface.baseOpacity;let T=!1,y=E.LINEAR_MIPMAP_LINEAR,g=!1,x=0;for(let b=r;b>=0;b--){const t=e.surface.layerViewByIndex(b,p.MAP),r=d(t),I=C(e,b,r),w=t.layer.opacity;if(!I||0===w&&!l)continue;const k=!a(t.layer)&&!T;k&&(T=!0);let O=!1;u.forEach((e=>{e.start===b&&(e.output=s?P.Composite:c&&k?this.backgroundIsGrid?P.GridComposite:P.ColorComposite:P.Composite,e.baseOpacity=k?_:1,F.push(e),this._composition.openGroup(i),O=!0)})),this._passParameters.baseOpacity=k&&!O&&_<1?_:1;const M=0===x,D=O?P.GroupBackgroundComposite:c&&M?this.backgroundIsGrid?P.GridComposite:P.ColorComposite:P.Composite,L=A[h(t)?t.layer.blendMode:"normal"];for(this._passParameters.opacity=w,m(I)?g=this._composition.drawVectorData(this._passParameters,D,i,L,I,n,this.tileSize,g):f(I)?(this._composition.drawImageryTileData(this._passParameters,D,i,L,I),this._hasNearestInterpolation(I)&&(y=E.NEAREST)):this._dataToTexture(I)&&(this._passParameters.texture=I.sourceLayerInfo.data.texture,this._passParameters.offset=I.offset,this._passParameters.scale=I.scale,this._composition.drawRasterData(this._passParameters,D,i,L));F.length>0&&F[F.length-1].end===b;){const e=F.pop();this._passParameters.baseOpacity=e.baseOpacity,this._passParameters.opacity=e.opacity,this._passParameters.offset=o,this._passParameters.scale=1,this._composition.drawGroup(this._passParameters,e.output,i,A[e.blendMode])}x++}const I=e.renderData,w=l||T&&_<1,k=I.ensureTexture(i,w,(()=>this._buildTexture(i,w,y)));this._composition.copyFBOToTexture(k),this._composition.unbind(),I.setTextureReference(new b(k,t,v,T?1:_,0,1))}_hasNearestInterpolation(e){const t=e.sourceLayerInfo.data;return!!t.source&&"nearest"===t.interpolation}_dataToTexture(e){if(_(e)){const t=e.sourceLayerInfo;t.data=this._buildTexture(t.data,!0),e.tile.setMemoryDirty()}return T(e)}setBackground(e){this._backgroundColor!==e&&(this._backgroundColor=e,this._backgroundDirty=!0)}_buildTexture(e,t,r=E.LINEAR_MIPMAP_LINEAR){if(null==e)return null;const s=new R;s.wrapMode=M.CLAMP_TO_EDGE,s.samplingMode=r,s.maxAnisotropy=this._maxAnisotropy,s.preMultiplyAlpha=!0,s.flipped=!0,s.hasMipmap=!0,t||(s.pixelFormat=D.RGB);const o=this._rctx;let a;if("number"==typeof e){s.width=s.height=e;const t=`${e} ${s.pixelFormat}`;a=this._cache.pop(t),a?a.retain():a=new w(new L(o,s),this._cache)}else if(n(e)){s.isOpaque=e.isOpaque,s.isOpaque&&(s.pixelFormat=D.RGB);const t=`${e} ${s.pixelFormat}`;a=this._cache.pop(t),a?(a.retain(),a.texture.setData(e.image)):a=new w(new L(o,s,e.image),this._cache),e.release()}else try{s.width=e.width,s.height=e.height,a=new w(new L(o,s,e))}catch(c){a=new w(O(o)),console.warn("TileRenderer: failed to execute 'texImage2D', cross-origin image may not be loaded.")}const i=o.bindTexture(a.texture,L.TEXTURE_UNIT_FOR_UPDATES);return a.generateMipmap(),o.bindTexture(i,L.TEXTURE_UNIT_FOR_UPDATES),a}get test(){return{backgroundTexture:this._backgroundTexture}}}function C(e,t,o){q.layerIndex=t,q.vtlNeighborInfos.clear();const a=e.layerInfo[p.MAP][t];if(r(q.offset,0,0),q.tile=e,q.scale=1,q.sourceLod=e.lij,q.sourceLayerInfo=a,q.isVTLBackground=o,a.data)return o&&e.forEachLoadedNeighbor(((r,s)=>{if(r.level!==e.level)return;const o=r.layerInfo[p.MAP][t];if(!y(o)||a.data===o.data)return;const i=q.vtlNeighborInfos.pushNew();i.offset=z[s],i.sourceLod=r.lij,i.sourceLayerInfo=o})),q;const i=a.upsampleInfo;if(i){const e=i.tile.layerInfo[p.MAP][t];return q.tile=i.tile,s(q.offset,i.offset),q.scale=i.scale,q.sourceLod=i.tile.lij,q.sourceLayerInfo=e,q}return o?q:null}function B(e){return e.uid}function S(e){let t="normal"!==e.blendMode;return i(e.parent)&&(t=S(e.parent)||t),t}function U(e,t){i(e.parent)&&U(e.parent,t);const r=B(e);if(null!=r&&""!==r){const s=G.get(r);s?s.start=t:G.set(r,new j(t,t,e.blendMode,e.opacity,P.Composite,1))}}const G=new Map,F=new Array,q=new I,v={offset:[0,0],scale:1},z=new Array;z[l.NORTH]=[0,-1],z[l.NORTH_EAST]=[-1,-1],z[l.EAST]=[-1,0],z[l.SOUTH_EAST]=[-1,1],z[l.SOUTH]=[0,1],z[l.SOUTH_WEST]=[1,1],z[l.WEST]=[1,0],z[l.NORTH_WEST]=[1,-1];export{j as GroupInfo,N as TileRenderer};
