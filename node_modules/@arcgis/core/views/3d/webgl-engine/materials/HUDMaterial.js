/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.29/esri/copyright.txt for details.
*/
import has from"../../../../core/has.js";import{clamp as e}from"../../../../core/mathUtils.js";import{fromMat4 as t}from"../../../../core/libs/gl-matrix-2/math/mat3.js";import{create as r}from"../../../../core/libs/gl-matrix-2/factories/mat3f64.js";import{invert as s}from"../../../../core/libs/gl-matrix-2/math/mat4.js";import{create as i}from"../../../../core/libs/gl-matrix-2/factories/mat4f64.js";import{fromValues as a}from"../../../../core/libs/gl-matrix-2/factories/vec2f64.js";import{s as n,e as o,n as l,f as c,h as f,c as p,l as u,q as m,t as h,k as d,g}from"../../../../chunks/vec32.js";import{create as S,fromValues as O}from"../../../../core/libs/gl-matrix-2/factories/vec3f64.js";import{fromArray as b,create as A,fromValues as T}from"../../../../core/libs/gl-matrix-2/factories/vec4f64.js";import{isMat4 as v}from"../../../../core/libs/gl-matrix-2/types/mat4.js";import{create as E}from"../../../../geometry/support/aaBoundingRect.js";import{BufferViewVec4u8 as I}from"../../../../geometry/support/buffer/BufferView.js";import{evaluateModelTransformScale as _}from"../../layers/support/FastSymbolUpdates.js";import{debugFlags as y}from"../../support/debugFlags.js";import{newLayout as R}from"../../support/buffer/InterleavedLayout.js";import{isColorAlphaHighlightOrOID as x,ShaderOutput as P}from"../core/shaderLibrary/ShaderOutput.js";import{HUDVerticalPixelOffset as C}from"../core/shaderLibrary/hud/HUD.glsl.js";import{GLTextureMaterial as D,GLTextureMaterialBindParameters as j}from"../lib/GLTextureMaterial.js";import{Material as L,RenderOccludedFlag as N}from"../lib/Material.js";import{RenderSlot as U}from"../lib/RenderSlot.js";import{applyScaleFactor as w,applyPrecomputedScaleFactor as F,precomputeScaleFactor as M}from"../lib/screenSizePerspectiveUtils.js";import{assert as z}from"../lib/Util.js";import{VertexAttribute as V}from"../lib/VertexAttribute.js";import{ScaleInfo as B}from"./ScaleInfo.js";import{writePosition as G,writeNormal as q,writeColor as W,writeBufferVec4 as H,writeBufferVec4Zeros as X,writeObjectAndLayerIdColor as Y}from"./internal/bufferWriterUtils.js";import{verticalOffsetAtDistance as Z}from"./internal/MaterialUtil.js";import{c as k}from"../../../../chunks/HUDMaterial.glsl.js";import{HUDMaterialTechnique as J}from"../shaders/HUDMaterialTechnique.js";import{HUDMaterialTechniqueConfiguration as K}from"../shaders/HUDMaterialTechniqueConfiguration.js";class Q extends L{constructor(e){super(e,new Ae),this._configuration=new K,this.produces=new Map([[U.HUD_MATERIAL,e=>x(e)&&!this.parameters.drawInSecondSlot],[U.LABEL_MATERIAL,e=>x(e)&&this.parameters.drawInSecondSlot],[U.OCCLUSION_PIXELS,()=>this.parameters.occlusionTest],[U.DRAPED_MATERIAL,e=>x(e)]])}getConfiguration(e,t){return this._configuration.output=e,this._configuration.hasSlicePlane=this.parameters.hasSlicePlane,this._configuration.hasVerticalOffset=!!this.parameters.verticalOffset,this._configuration.hasScreenSizePerspective=!!this.parameters.screenSizePerspective,this._configuration.screenCenterOffsetUnitsEnabled="screen"===this.parameters.centerOffsetUnits,this._configuration.hasPolygonOffset=this.parameters.polygonOffset,this._configuration.draped=this.parameters.draped,this._configuration.occlusionTestEnabled=this.parameters.occlusionTest,this._configuration.pixelSnappingEnabled=this.parameters.pixelSnappingEnabled,this._configuration.signedDistanceFieldEnabled=this.parameters.textureIsSignedDistanceField,this._configuration.sampleSignedDistanceFieldTexelCenter=this.parameters.sampleSignedDistanceFieldTexelCenter,this._configuration.vvSize=!!this.parameters.vvSize,this._configuration.vvColor=!!this.parameters.vvColor,this._configuration.occlusionPass=t.slot===U.OCCLUSION_PIXELS&&this.parameters.occlusionTest,e===P.Color&&(this._configuration.debugDrawLabelBorder=!!y.LABELS_SHOW_BORDER),this._configuration.depthEnabled=this.parameters.depthEnabled,this._configuration.transparencyPassType=t.transparencyPassType,this._configuration.multipassEnabled=t.multipassEnabled,this._configuration.cullAboveGround=t.multipassTerrain.cullAboveGround,this._configuration}intersect(e,r,i,a,h,d){if(!(i.options.selectionMode&&i.options.hud&&e.visible&&i.point))return;const g=this.parameters,O=i.point,b=i.camera;let{scaleX:A,scaleY:T}=this._getScreenScale(e);A*=b.pixelRatio,T*=b.pixelRatio,t(ce,r),e.attributes.has(V.FEATUREATTRIBUTE)&&te(ce);const v=e.attributes.get(V.POSITION),E=e.attributes.get(V.SIZE),I=e.attributes.get(V.NORMAL),_=e.attributes.get(V.CENTEROFFSETANDDISTANCE);z(v.size>=3);const y=k(g),R="screen"===this.parameters.centerOffsetUnits;for(let t=0;t<v.data.length/v.size;t++){const e=t*v.size;n(ie,v.data[e],v.data[e+1],v.data[e+2]),o(ie,ie,r);const a=t*E.size;Oe[0]=E.data[a]*A,Oe[1]=E.data[a+1]*T,o(ie,ie,b.viewMatrix);const h=t*_.size;if(n(ue,_.data[h],_.data[h+1],_.data[h+2]),!R&&(ie[0]+=ue[0],ie[1]+=ue[1],0!==ue[2])){const e=ue[2];l(ue,ie),c(ie,ie,f(ue,ue,e))}const x=t*I.size;if(n(ae,I.data[x],I.data[x+1],I.data[x+2]),this._normalAndViewAngle(ae,ce,b,de),this._applyVerticalOffsetTransformationView(ie,de,b,se),b.applyProjection(ie,ne),ne[0]>-1){R&&(ue[0]||ue[1])&&(ne[0]+=ue[0]*b.pixelRatio,0!==ue[1]&&(ne[1]+=w(ue[1],se.factorAlignment)*b.pixelRatio),b.unapplyProjection(ne,ie)),ne[0]+=this.parameters.screenOffset[0]*b.pixelRatio,ne[1]+=this.parameters.screenOffset[1]*b.pixelRatio,ne[0]=Math.floor(ne[0]),ne[1]=Math.floor(ne[1]),F(Oe,se.factor,Oe);const e=ge*b.pixelRatio;let t=0;if(g.textureIsSignedDistanceField&&(t=g.outlineSize*b.pixelRatio/2),re(O,ne[0],ne[1],Oe,e,t,g,y)){const e=i.ray;if(o(le,ie,s(pe,b.viewMatrix)),ne[0]=O[0],ne[1]=O[1],b.unprojectFromRenderScreen(ne,ie)){const t=S();p(t,e.direction);const r=1/u(t);f(t,t,r);d(m(e.origin,ie)*r,t,-1,!0,1,le)}}}}}intersectDraped(e,t,r,s,i,a){const n=e.attributes.get(V.POSITION),o=e.attributes.get(V.SIZE),l=this.parameters,c=k(l);let{scaleX:f,scaleY:p}=this._getScreenScale(e);f*=e.screenToWorldRatio,p*=e.screenToWorldRatio;const u=Se*e.screenToWorldRatio;for(let m=0;m<n.data.length/n.size;m++){const t=m*n.size,r=n.data[t],h=n.data[t+1],d=m*o.size;Oe[0]=o.data[d]*f,Oe[1]=o.data[d+1]*p;let g=0;l.textureIsSignedDistanceField&&(g=l.outlineSize*e.screenToWorldRatio/2),re(s,r,h,Oe,u,g,l,c)&&i(a.dist,a.normal,-1,!1)}}createBufferWriter(){return new Ee(this)}_normalAndViewAngle(e,r,s,i){return v(r)&&(r=t(fe,r)),h(i.normal,e,r),o(i.normal,i.normal,s.viewInverseTransposeMatrix),i.cosAngle=d(oe,be),i}_updateScaleInfo(e,t,r){const s=this.parameters;null!=s.screenSizePerspective?M(r,t,s.screenSizePerspective,e.factor):(e.factor.scale=1,e.factor.factor=0,e.factor.minScaleFactor=0),null!=s.screenSizePerspectiveAlignment?M(r,t,s.screenSizePerspectiveAlignment,e.factorAlignment):(e.factorAlignment.factor=e.factor.factor,e.factorAlignment.scale=e.factor.scale,e.factorAlignment.minScaleFactor=e.factor.minScaleFactor)}applyShaderOffsetsView(e,t,r,s,i,a,n){const o=this._normalAndViewAngle(t,r,i,de);return this._applyVerticalGroundOffsetView(e,o,i,n),this._applyVerticalOffsetTransformationView(n,o,i,a),this._applyPolygonOffsetView(n,o,s[3],i,n),this._applyCenterOffsetView(n,s,n),n}applyShaderOffsetsNDC(e,t,r,s,i){return this._applyCenterOffsetNDC(e,t,r,s),null!=i&&p(i,s),this._applyPolygonOffsetNDC(s,t,r,s),s}_applyPolygonOffsetView(t,r,s,i,a){const n=i.aboveGround?1:-1;let o=Math.sign(s);0===o&&(o=n);const l=n*o;if(this.parameters.shaderPolygonOffset<=0)return p(a,t);const c=e(Math.abs(r.cosAngle),.01,1),u=1-Math.sqrt(1-c*c)/c/i.viewport[2];return f(a,t,l>0?u:1/u),a}_applyVerticalGroundOffsetView(e,t,r,s){const i=u(e),a=r.aboveGround?1:-1,n=r.computeRenderPixelSizeAtDist(i)*C,o=f(ie,t.normal,a*n);return g(s,e,o),s}_applyVerticalOffsetTransformationView(e,t,r,s){const i=this.parameters;if(!i.verticalOffset?.screenLength){if(i.screenSizePerspective||i.screenSizePerspectiveAlignment){const r=u(e);this._updateScaleInfo(s,r,t.cosAngle)}else s.factor.scale=1,s.factorAlignment.scale=1;return e}const a=u(e),n=i.screenSizePerspectiveAlignment??i.screenSizePerspective,o=Z(r,a,i.verticalOffset,t.cosAngle,n);return this._updateScaleInfo(s,a,t.cosAngle),f(t.normal,t.normal,o),g(e,e,t.normal)}_applyCenterOffsetView(e,t,r){const s="screen"!==this.parameters.centerOffsetUnits;return r!==e&&p(r,e),s&&(r[0]+=t[0],r[1]+=t[1],t[2]&&(l(ae,r),g(r,r,f(ae,ae,t[2])))),r}_applyCenterOffsetNDC(e,t,r,s){const i="screen"!==this.parameters.centerOffsetUnits;return s!==e&&p(s,e),i||(s[0]+=t[0]/r.fullWidth*2,s[1]+=t[1]/r.fullHeight*2),s}_applyPolygonOffsetNDC(e,t,r,s){const i=this.parameters.shaderPolygonOffset;if(e!==s&&p(s,e),i){const e=r.aboveGround?1:-1,a=e*Math.sign(t[3]);s[2]-=(a||e)*i}return s}createGLMaterial(e){return new $(e)}calculateRelativeScreenBounds(e,t,r=E()){return ee(this.parameters,e,t,r),r[2]=r[0]+e[0],r[3]=r[1]+e[1],r}_getScreenScale(e){const t=e.attributes.get(V.FEATUREATTRIBUTE);if(null==t)return{scaleX:1,scaleY:1};const r=b(t.data,he),[s,i]=_(me,this.parameters,r);return{scaleX:s,scaleY:i}}}class $ extends D{constructor(e){super({...e,...e.material.parameters})}selectProgram(e){return this.ensureTechnique(J,e)}beginSlot(e){return this.updateTexture(this._material.parameters.textureId),this._material.setParameters(this.textureBindParameters),this.selectProgram(e)}}function ee(e,t,r,s){s[0]=e.anchorPosition[0]*-t[0]+e.screenOffset[0]*r,s[1]=e.anchorPosition[1]*-t[1]+e.screenOffset[1]*r}function te(e){const t=e[0],r=e[1],s=e[2],i=e[3],a=e[4],n=e[5],o=e[6],l=e[7],c=e[8],f=1/Math.sqrt(t*t+r*r+s*s),p=1/Math.sqrt(i*i+a*a+n*n),u=1/Math.sqrt(o*o+l*l+c*c);return e[0]=t*f,e[1]=r*f,e[2]=s*f,e[3]=i*p,e[4]=a*p,e[5]=n*p,e[6]=o*u,e[7]=l*u,e[8]=c*u,e}function re(e,t,r,s,i,a,n,o){let l=t-i-(o[0]>0?s[0]*o[0]:0),c=l+s[0]+2*i,f=r-i-(o[1]>0?s[1]*o[1]:0),p=f+s[1]+2*i;const u=n.distanceFieldBoundingBox;return n.textureIsSignedDistanceField&&null!=u&&(l+=s[0]*u[0],f+=s[1]*u[1],c-=s[0]*(1-u[2]),p-=s[1]*(1-u[3]),l-=a,c+=a,f-=a,p+=a),e[0]>l&&e[0]<c&&e[1]>f&&e[1]<p}const se=new B,ie=S(),ae=S(),ne=A(),oe=S(),le=S(),ce=r(),fe=r(),pe=i(),ue=S(),me=S(),he=A(),de={normal:oe,cosAngle:0},ge=1,Se=2,Oe=[0,0],be=O(0,0,1);class Ae extends j{constructor(){super(...arguments),this.renderOccluded=N.Occlude,this.isDecoration=!1,this.color=T(1,1,1,1),this.texCoordScale=[1,1],this.polygonOffset=!1,this.anchorPosition=a(.5,.5),this.screenOffset=[0,0],this.shaderPolygonOffset=1e-5,this.textureIsSignedDistanceField=!1,this.sampleSignedDistanceFieldTexelCenter=!1,this.outlineColor=T(1,1,1,1),this.outlineSize=0,this.vvSizeEnabled=!1,this.vvSize=null,this.vvColor=null,this.vvOpacity=null,this.vvSymbolAnchor=null,this.vvSymbolRotationMatrix=null,this.hasSlicePlane=!1,this.pixelSnappingEnabled=!0,this.occlusionTest=!0,this.centerOffsetUnits="world",this.drawInSecondSlot=!1,this.depthEnabled=!0,this.draped=!1}}const Te=R().vec3f(V.POSITION).vec3f(V.NORMAL).vec2f(V.UV0).vec4u8(V.COLOR).vec2f(V.SIZE).vec4f(V.CENTEROFFSETANDDISTANCE).vec4f(V.FEATUREATTRIBUTE),ve=Te.clone().vec4u8(V.OBJECTANDLAYERIDCOLOR);class Ee{constructor(e){this._material=e,this.vertexBufferLayout=has("enable-feature:objectAndLayerId-rendering")?ve:Te}elementCount(e){return 6*e.attributes.get(V.POSITION).indices.length}write(e,t,r,s,i){G(r.attributes.get(V.POSITION),e,s.position,i,6),q(r.attributes.get(V.NORMAL),t,s.normal,i,6);const a=r.attributes.get(V.UV0).data;let n,o,l,c;if(null==a||a.length<4){const e=this._material.parameters;n=0,o=0,l=e.texCoordScale[0],c=e.texCoordScale[1]}else n=a[0],o=a[1],l=a[2],c=a[3];l=Math.min(1.99999,l+1),c=Math.min(1.99999,c+1);let f=r.attributes.get(V.POSITION).indices.length,p=i;const u=s.uv0;for(let g=0;g<f;++g)u.set(p,0,n),u.set(p,1,o),p++,u.set(p,0,l),u.set(p,1,o),p++,u.set(p,0,l),u.set(p,1,c),p++,u.set(p,0,l),u.set(p,1,c),p++,u.set(p,0,n),u.set(p,1,c),p++,u.set(p,0,n),u.set(p,1,o),p++;W(r.attributes.get(V.COLOR),4,s.color,i,6);const{data:m,indices:h}=r.attributes.get(V.SIZE);f=h.length;const d=s.size;p=i;for(let g=0;g<f;++g){const e=m[2*h[g]],t=m[2*h[g]+1];for(let r=0;r<6;++r)d.set(p,0,e),d.set(p,1,t),p++}if(r.attributes.get(V.CENTEROFFSETANDDISTANCE)?H(r.attributes.get(V.CENTEROFFSETANDDISTANCE),s.centerOffsetAndDistance,i,6):X(s.centerOffsetAndDistance,i,6*f),r.attributes.get(V.FEATUREATTRIBUTE)?H(r.attributes.get(V.FEATUREATTRIBUTE),s.featureAttribute,i,6):X(s.featureAttribute,i,6*f),null!=r.objectAndLayerIdColor){const e=r.attributes.get(V.POSITION)?.indices;if(e){const t=e.length,a=s.getField(V.OBJECTANDLAYERIDCOLOR,I);Y(r.objectAndLayerIdColor,a,t,i,6)}}}}export{Q as HUDMaterial,Ae as Parameters};
