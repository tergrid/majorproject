/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.29/esri/copyright.txt for details.
*/
import{isSome as t,equals as e}from"../../../core/arrayUtils.js";import{asinClamped as s}from"../../../core/mathUtils.js";import{dot as r,subtract as n,exactEquals as i,set as o,squaredDistance as c}from"../../../core/libs/gl-matrix-2/math/vec2.js";import{create as u}from"../../../core/libs/gl-matrix-2/factories/vec2f64.js";import{r as a,j as f,a as h,z as l,p as d,s as p,c as m,f as g,G as L,k,b as _,n as M}from"../../../chunks/vec32.js";import{clone as P,create as x,fromValues as v,UNIT_Z as y}from"../../../core/libs/gl-matrix-2/factories/vec3f64.js";import{s as T,g as w}from"../../../chunks/vec42.js";import{create as j}from"../../../core/libs/gl-matrix-2/factories/vec4f64.js";import{toRadians as q}from"../../../geometry/support/geodesicConstants.js";import{directGeodeticSolver as z,inverseGeodeticSolver as A,InverseGeodeticSolverResult as b}from"../../../geometry/support/geodesicUtils.js";import{create as D,intersectLine as E,signedDistance as N,projectPoint as R,fromPositionAndNormal as U,fromPoints as Z,distance as I,getNormal as G}from"../../../geometry/support/plane.js";import{k as S,l as C,p as O,g as F,m as H}from"../../../chunks/sphere.js";import{tangentFrame as V}from"../../3d/support/mathUtils.js";import{fromVec3 as Y,clone as B,fromValues as J,asVec2 as K,create as Q}from"./normalizedPoint.js";import{vectorsHaveCloseZ as W,isClose as X,intersectVerticalPlaneAndVerticalCylinder as $,isPointInsidePlane as tt,projectPointToLineLike as et,projectPointToVerticalCylinder as st,projectPointToVerticalPlane as rt,VerticalPlaneType as nt,intersectLineLikes as it,intersectVerticalPlaneAndLineLike as ot,intersectLineLikeAndVerticalCylinder as ct,intersectLineLikeAndCircle as ut,intersectVerticalPlanes as at,intersectVerticalCylinders as ft,pointsInsidePlane as ht,intersectVerticalPlaneAndPoint as lt}from"../../support/geometry3dUtils.js";import{LineType as dt}from"../../support/geometry2dUtils.js";class pt{intersect(t){return Ot(this,t)}closestPoints(t){return[this.closestTo(t)]}}class mt extends pt{constructor(t){super(),this.point=t}equals(t){return this===t||ge(t)&&f(this.point,t.point)}closestTo(){return B(this.point)}}class gt extends pt{constructor(t,e,s){super(),this.start=t,this.end=e,this.lineLike={start:t,end:e,type:s}}equals(t){return this===t||Le(t)&&this.lineLike.type===t.lineLike.type&&f(this.start,t.start)&&f(this.end,t.end)}closestTo(t){const e=et(t,this.lineLike);return Y(e)}}class Lt extends gt{constructor(t,e){super(t,e,dt.LINE)}}class kt extends gt{constructor(t,e){super(t,e,dt.RAY)}}class _t extends pt{constructor(t){super(),this.constraints=t}equals(t){return this===t||me(t)&&e(this.constraints,t.constraints,((t,e)=>t.equals(e)))}closestTo(t){let e,s=1/0;for(const r of this.constraints){const n=r.closestTo(t),i=h(t,n);i<s&&(s=i,e=n)}return e?B(e):t}closestPoints(t){return this.constraints.flatMap((e=>e===this?[]:e.closestPoints(t)))}}class Mt extends pt{constructor(t,e){super(),this.center=t,this.radius=e}equals(t){return this===t||Me(t)&&this.center[0]===t.center[0]&&this.center[1]===t.center[1]&&this.radius===t.radius}closestTo(t){const e=st(t,this.center,this.radius);return Y(e)}}class Pt extends pt{constructor(t,e){super(),this.center=t,this.radius=e}equals(t){return this===t||Pe(t)&&f(this.center,t.center)&&this.radius===t.radius}closestTo(t){const e=st(t,this.center,this.radius);return e[2]=this.center[2],Y(e)}asCircle(){return new xt(B(this.center),this.radius,J(0,0,1))}}class xt extends pt{constructor(t,e,s,r=void 0){super(),this.center=t,this.radius=e,this.normal=s,this.slicePlane=r}equals(t){return this===t||xe(t)&&f(this.center,t.center)&&f(this.normal,t.normal)&&this.radius===t.radius}closestTo(t){const{center:e,radius:s}=this;R(this.getPlane(yt),t,vt);const r=l(vt,vt,e),n=d(r);if(X(n,0))return B(t);const i=s/Math.sqrt(n),o=a(x(),e,r,i),{slicePlane:c}=this;if(c&&!tt(c,o)){const e=Yt(c,this);return e?.closestTo(t)??B(t)}return Y(o)}getPlane(t=D()){return U(this.center,this.normal,t)}}const vt=x(),yt=D();class Tt extends pt{constructor(t){super(),this.z=t}equals(t){return this===t||ke(t)&&this.z===t.z}closestTo(t){return Y(v(t[0],t[1],this.z))}getPlane(t=D()){return p(wt,0,0,this.z),U(wt,y,t)}}const wt=x();class jt extends pt{constructor(t,e,s){super(),this.start=t,this.end=e,this.planeLike={start:K(t),end:K(e),type:s}}equals(t){return this===t||_e(t)&&this.planeLike.type===t.planeLike.type&&f(this.start,t.start)&&f(this.end,t.end)}closestTo(t){return Y(rt(t,this.planeLike))}closestEndTo(t){const{start:e,end:s}=this.planeLike;return Math.sign(r(n(qt,s,e),n(zt,K(t),e)))>0?this.end:this.start}getPlane(t=D()){const e=m(At,this.end);return e[2]+=1,Z(this.start,this.end,e,t)}getSlicePlane(t=D()){const{start:e,end:s,type:r}=this.planeLike;if(r===nt.PLANE)return;const n=p(At,e[0],e[1],0),i=p(bt,s[0],s[1],0),o=g(bt,i,n);return U(n,o,t),t}}const qt=u(),zt=u(),At=x(),bt=x();class Dt extends jt{constructor(t,e){super(t,e,nt.HALF_PLANE)}}class Et extends jt{constructor(t,e){super(t,e,nt.PLANE)}}class Nt extends pt{constructor(t,e){super(),this.sphere=S(t,e)}equals(t){return this===t||ve(t)&&C(this.sphere,t.sphere)}closestTo(t){const e=O(this.sphere,t,x());return Y(e)}get center(){return F(this.sphere)}get radius(){return this.sphere[3]}}class Rt extends pt{constructor(t,e,s){super(),this.start=t,this.end=e,this.getZ=s,this.planeLike={start:K(t),end:K(e),type:nt.PLANE}}equals(t){return this===t||ye(t)&&f(this.start,t.start)&&f(this.end,t.end)&&this.getZ===t.getZ}closestTo(t){return Ct(this,t)}addIfOnTheGround(t,e){for(const s of e){const e=this.getZ(s[0],s[1])??0;X(s[2],e)&&(s[2]=e,t.push(s))}}}class Ut extends pt{constructor(t,e,s,r,n){super(),this._origin=t,this._spatialReference=e,this._distanceMeters=s,this._elevationMeters=r,this._directionDegrees=n}equals(t){return this===t||Te(t)&&i(this._origin,t._origin)&&this._distanceMeters===t._distanceMeters&&this._elevationMeters===t._elevationMeters&&this._directionDegrees===t._directionDegrees}closestTo([t,e,s]){if(o(Zt,t,e),null!=this._directionDegrees&&null!=this._distanceMeters)z(Zt,this._origin,this._directionDegrees,this._distanceMeters,this._spatialReference);else if(null!=this._directionDegrees)Gt(Zt,this._origin,this._directionDegrees,Zt,this._spatialReference);else if(null!=this._distanceMeters){const{azimuth:t}=A(It,this._origin,Zt,this._spatialReference);z(Zt,this._origin,t??0,this._distanceMeters,this._spatialReference)}return Q(Zt[0],Zt[1],this._elevationMeters??s)}}const Zt=[0,0],It=new b;function Gt(t,e,s,r,n){let{azimuth:i,distance:o}=A(St,e,r,n);i??=0;let c=o*Math.cos((i-s)*q);c=Math.max(0,c),z(t,e,s,c,n)}const St=new b;function Ct(t,e){const s=rt(e,t.planeLike);return s[2]=t.getZ(s[0],s[1])??we,Y(s)}function Ot(t,e){if(me(t)){const s=[];for(const r of t.constraints){const t=r.intersect(e);t&&s.push(t)}return pe(s)}if(me(e))return Ot(e,t);if(ye(t))return fe(t,e);if(ye(e))return fe(e,t);if(ge(t)){const{point:s}=t;if(ge(e))return f(s,e.point)?t:void 0;const r=e.closestTo(s);return L(r,s)?t:void 0}if(Le(t)){if(ge(e))return Ot(e,t);if(Le(e))return le(it(t.lineLike,e.lineLike));if(ke(e))return Ft(t,e);if(_e(e))return le(ot(e.planeLike,t.lineLike));if(Me(e))return le(ct(t.lineLike,e.center,e.radius));if(xe(e))return le(ut(t.lineLike,e));if(Pe(e))return Ht(t,e);if(ve(e))return Vt(t,e)}else if(ke(t)){if(ge(e)||Le(e))return Ot(e,t);if(ke(e))return Bt(t,e);if(_e(e))return Jt(t,e);if(Me(e))return Kt(t,e);if(xe(e))return Wt(t,e);if(Pe(e))return Qt(t,e);if(ve(e))return Xt(t,e)}else if(_e(t)){if(ge(e)||Le(e)||ke(e))return Ot(e,t);if(_e(e))return he(at(t.planeLike,e.planeLike));if(Me(e))return he($(t.planeLike,e.center,e.radius));if(xe(e))return te(t,e);if(Pe(e))return $t(t,e);if(ve(e))return ee(t,e)}else if(Me(t)){if(ge(e)||Le(e)||ke(e)||_e(e))return Ot(e,t);if(Me(e))return he(ft(K(t.center),t.radius,K(e.center),e.radius));if(xe(e))return se();if(Pe(e))return re(t,e);if(ve(e))return ne()}else if(xe(t)){if(ge(e)||Le(e)||ke(e)||_e(e)||Me(e))return Ot(e,t);if(xe(e))return ie();if(Pe(e))return ie(e.asCircle());if(ve(e))return oe()}else if(Pe(t)){if(ge(e)||Le(e)||ke(e)||_e(e)||Me(e)||xe(e))return Ot(e,t);if(Pe(e))return ce(e,t);if(ve(e))return ue()}else if(ve(t)){if(ge(e)||Le(e)||ke(e)||_e(e)||Me(e)||Pe(e))return Ot(e,t);if(ve(e))return ae()}}const Ft=(()=>{const t=D();return(e,s)=>{const{start:r,end:n}=e;if(W(r,n)&&X(r[2],s.z))return e;const i=x();return E(s.getPlane(t),r,n,i)?new mt(Y(i)):void 0}})();function Ht({lineLike:t},{center:e,radius:s}){const r=e[2];return le(ct(t,e,s).filter((t=>X(t[2],r))))}function Vt({lineLike:t},{sphere:e}){return le(H(e,t.start,t.end))}const Yt=(()=>{const t=j(),e=x(),r=x();return(n,i,o)=>{const{normal:c,center:u,radius:f}=i;V(c,e,r);const h=G(n),l=f*k(h,e),d=f*k(h,r);T(t,u[0],u[1],u[2],1);const p=w(n,t),m=Math.hypot(l,d),g=X(m,0);if(X(I(n,u),0)){if(g)return i;if(X(f,0))return!o||tt(o,u)?new mt(B(u)):void 0;_(e,h,c),M(e,e);const t=new Array,s=P(u);a(s,s,e,f),o&&!tt(o,s)||t.push(s);const r=P(u);return a(r,r,e,-f),o&&!tt(o,r)||t.push(r),le(t)}if(g)return;const L=-p/m;if(Math.abs(L)>1||X(L,1))return;const v=Math.atan(l/d),y=s(L)-v,j=Math.PI-y,q=new Array,z=x();a(z,u,e,f*Math.cos(y)),a(z,z,r,f*Math.sin(y)),q.push(z);const A=x();return a(A,u,e,f*Math.cos(j)),a(A,A,r,f*Math.sin(j)),q.push(A),le(o?ht(o,q):q)}})();function Bt(t,e){return X(t.z,e.z)?t:void 0}function Jt({z:t},{planeLike:e}){const[s,r]=e.start,[n,i]=e.end,o=J(s,r,t),c=J(n,i,t);return e.type===nt.PLANE?new Lt(o,c):new kt(o,c)}function Kt(t,e){const[s,r]=e.center;return new Pt(J(s,r,t.z),e.radius)}function Qt(t,e){return X(e.center[2],t.z)?e:void 0}const Wt=(()=>{const t=D();return(e,s)=>Yt(e.getPlane(t),s,s.slicePlane)})();function Xt(t,{center:e,radius:s}){const r=Math.abs(e[2]-t.z);if(r>s&&!X(r,s))return;const n=J(e[0],e[1],t.z),i=Math.sqrt(s**2-r**2);return X(i,0)?void 0:new Pt(n,i)}const $t=(()=>{const t=D();return(e,{center:s,radius:r})=>{const n=$(e.planeLike,s,r),i=s[2];e.getSlicePlane(t);const o=new Array;for(const[c,u]of n){const e=[c,u,i];tt(t,e)&&o.push(e)}return le(o)}})(),te=(()=>{const t=D(),e=D();return(s,r)=>Yt(s.getPlane(t),r,s.getSlicePlane(e))})(),ee=(()=>{const t=D();return(e,{center:s,radius:r})=>{const n=e.getPlane(t),i=N(n,s),o=Math.abs(i);if(o>r&&!X(o,r))return;const c=P(G(n)),u=a(x(),s,c,i),f=Math.sqrt(r**2-i**2);return X(f,0)?new mt(Y(R(n,s,x()))):new xt(Y(u),f,c,e.getSlicePlane())}})();function se(t,e){}function re(t,e){const s=c(K(t.center),K(e.center));if(X(s,0)&&X(t.radius,e.radius))return e;return de(ft(K(t.center),t.radius,K(e.center),e.radius),e.center[2])}function ne(t,e){}function ie(t,e){}function oe(t,e){}function ce(t,e){if(!W(t.center,e.center))return;const s=c(K(t.center),K(e.center));if(X(s,0)&&X(t.radius,e.radius))return t;return de(ft(K(t.center),t.radius,K(e.center),e.radius),t.center[2])}function ue(t,e){}function ae(t,e){}function fe(t,e){const{planeLike:s,getZ:r}=t,n=new Array;if(ge(e))t.addIfOnTheGround(n,lt(s,e.point));else if(Le(e))t.addIfOnTheGround(n,ot(s,e.lineLike));else if(Me(e))for(const[i,o]of $(s,e.center,e.radius)){const t=r(i,o);null!=t&&n.push(v(i,o,t))}else if(_e(e)||ye(e))for(const[i,o]of at(s,e.planeLike)){const t=r(i,o)??we;n.push(v(i,o,t))}return le(n)}function he(t){return pe(t.map((([t,e])=>{const s=J(t,e,0),r=J(t,e,1);return new Lt(s,r)})))}function le(t){return pe(t.map((t=>t?new mt(Y(t)):void 0)))}function de(t,e){return le(t.map((([t,s])=>[t,s,e])))}function pe(e){if(0!==e.length)return 1===e.length?e[0]??void 0:new _t(e.filter(t))}function me(t){return t instanceof _t}function ge(t){return t instanceof mt}function Le(t){return t instanceof gt}function ke(t){return t instanceof Tt}function _e(t){return t instanceof jt}function Me(t){return t instanceof Mt}function Pe(t){return t instanceof Pt}function xe(t){return t instanceof xt}function ve(t){return t instanceof Nt}function ye(t){return t instanceof Rt}function Te(t){return t instanceof Ut}const we=0;export{xt as CircleConstraint,pt as Constraint,Rt as DrapedLineConstraint,Ut as GeodesicConstraint,Pt as HorizontalCircleConstraint,Tt as HorizontalPlaneConstraint,Lt as LineConstraint,gt as LineLikeConstraint,mt as PointConstraint,kt as RayConstraint,_t as SetConstraint,Nt as SphereConstraint,Mt as VerticalCylinderConstraint,Dt as VerticalHalfPlaneConstraint,Et as VerticalPlaneConstraint,jt as VerticalPlaneLikeConstraint,pe as constraintOrSet,ge as isPoint};
