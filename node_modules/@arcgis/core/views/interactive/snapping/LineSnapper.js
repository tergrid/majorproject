/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.29/esri/copyright.txt for details.
*/
import{cyclicalPI as e,cyclical2PI as t}from"../../../core/Cyclical.js";import{valueInUnit as r,createAngle as s}from"../../../core/quantityUtils.js";import{create as o}from"../../../core/libs/gl-matrix-2/factories/vec3f64.js";import{absoluteHeightElevationInfo as i}from"../../../support/elevationInfoUtils.js";import{fromAnyMapPoint as n,fromVec3 as a}from"../sketch/normalizedPoint.js";import{SnappingAlgorithm as p}from"./SnappingAlgorithm.js";import{editEdgeToSnappingEdge as d,squaredScreenDistance as l}from"./snappingUtils.js";import{LineSnappingCandidate as h}from"./candidates/LineSnappingCandidate.js";import{vectorToScreenPoint as c}from"../support/viewUtils.js";import{radiansGeographicBetweenVec as g,pointFromDistanceAlongAzimuth as m}from"../../support/angularMeasurementUtils.js";import{geodesicDistance as f}from"../../support/geodesicLengthMeasurementUtils.js";import{projectPointToLineLike as u}from"../../support/geometry3dUtils.js";import{LineType as j}from"../../support/geometry2dUtils.js";class x extends p{snapNewVertex(e,t){const r=t.editGeometryOperations.data.components[0],s=r.edges.length,o=[];if(s<1)return o;const{spatialReference:n}=t,a=c(e,n,i,this.view),{view:p}=this,l=r.edges[s-1];let h=l;do{if(this.edgeExceedsShortLineThreshold(h,t)){const r=d(h,p,t);this._processCandidateProposal(r.left,r.right,e,a,t,o)}h=h.leftVertex.leftEdge}while(h&&h!==l);return o}snapExistingVertex(e,t){const r=[],s=t.vertexHandle,o=s.component;if(o.edges.length<2)return r;const{view:a}=this,{spatialReference:p}=t,l=c(e,p,i,a),h=s.leftEdge,g=s.rightEdge;h&&g&&this.edgeExceedsShortLineThreshold(h,t)&&this.edgeExceedsShortLineThreshold(g,t)&&this._processCandidateProposal(n(h.leftVertex.pos,a,t),n(g.rightVertex.pos,a,t),e,l,t,r);const m=o.edges[0];let f=m;do{if(f!==s.leftEdge&&f!==s.rightEdge&&this.edgeExceedsShortLineThreshold(f,t)){const s=d(f,a,t);this._processCandidateProposal(s.left,s.right,e,l,t,r)}f=f.rightVertex.rightEdge}while(f&&f!==m);return r}_processCandidateProposal(e,t,r,s,n,p){const{spatialReference:d,pointer:g}=n,m=o();this._projectedLine(m,e,t,r,n);const f=a(m);l(s,c(f,d,i,this.view))<this.squaredProximityThreshold(g)&&p.push(new h({lineStart:e,lineEnd:t,targetPoint:f,isDraped:"on-the-ground"===n.elevationInfo?.mode}))}_projectedLine(e,t,r,s,o){this._projectToLineGeodesic(e,t,r,s,o)||this._projectToLinePlanar(e,s,t,r)}_projectToLineGeodesic(o,i,n,a,{spatialReference:p}){const d=g(i,n,p,p);if(null==d)return!1;const l=g(n,a,p,p);if(null==l)return!1;const h=f(n,a,p);if(null==h)return!1;const c=Math.abs(e.shortestSignedDiff(d,l))>Math.PI/2?t.normalize(d+Math.PI):d;return m(o,n,p,r(h,"meters"),s(c,"radians","geographic"),"geodesic"),o[2]=a[2],!0}_projectToLinePlanar(e,t,r,s){u(t,{start:r,end:s,type:j.LINE},e),e[2]=t[2]}}export{x as LineSnapper};
