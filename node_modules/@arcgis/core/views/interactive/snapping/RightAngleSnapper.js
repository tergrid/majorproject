/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.29/esri/copyright.txt for details.
*/
import{cyclical2PI as e}from"../../../core/Cyclical.js";import{createAngle as t,valueInUnit as r}from"../../../core/quantityUtils.js";import{subtract as i,dot as o,squaredLength as n,scaleAndAdd as s}from"../../../core/libs/gl-matrix-2/math/vec2.js";import{create as a}from"../../../core/libs/gl-matrix-2/factories/vec2f64.js";import{f as c,s as p,r as h}from"../../../chunks/vec32.js";import{create as d}from"../../../core/libs/gl-matrix-2/factories/vec3f64.js";import{absoluteHeightElevationInfo as g}from"../../../support/elevationInfoUtils.js";import{VerticalHalfPlaneConstraint as l}from"../sketch/constraints.js";import{fromAnyMapPoint as f,asVec2 as m,fromValues as u,fromVec3 as x}from"../sketch/normalizedPoint.js";import{SnappingAlgorithm as j}from"./SnappingAlgorithm.js";import{squaredScreenDistance as v}from"./snappingUtils.js";import{RightAngleSnappingCandidate as V,OtherVertexType as _}from"./candidates/RightAngleSnappingCandidate.js";import{vectorToScreenPoint as E}from"../support/viewUtils.js";import{radiansGeographicBetweenVec as R,pointFromDistanceAlongAzimuth as y}from"../../support/angularMeasurementUtils.js";import{geodesicDistance as S}from"../../support/geodesicLengthMeasurementUtils.js";class k extends j{snapNewVertex(e,t){const r=t.editGeometryOperations.data.components[0],i=[];if(r.vertices.length<2)return i;const{view:o}=this,n=E(e,t.spatialReference,g,o),s=r.vertices.at(-1);this._checkForSnappingCandidate(i,s.leftEdge,s,s.leftEdge.leftVertex,e,n,t);const a=r.vertices[0];return this._checkForSnappingCandidate(i,a.rightEdge,a,a.rightEdge.rightVertex,e,n,t),i}snapExistingVertex(e,t){const r=[],i=t.vertexHandle;if(i.component.vertices.length<3)return r;const{view:o}=this,n=E(e,t.spatialReference,g,o),s=i.leftEdge,a=i.rightEdge;if(s?.leftVertex.leftEdge){const i=s.leftVertex.leftEdge;this._checkForSnappingCandidate(r,i,i.rightVertex,i.leftVertex,e,n,t)}if(a?.rightVertex.rightEdge){const i=a.rightVertex.rightEdge;this._checkForSnappingCandidate(r,i,i.leftVertex,i.rightVertex,e,n,t)}return r}_checkForSnappingCandidate(e,t,r,i,o,n,s){if(!this.edgeExceedsShortLineThreshold(t,s))return;const a=this.view,c=f(r.pos,a,s),p=f(i.pos,a,s);this._checkForSnappingCandidateNormalized(e,p,c,o,n,s)}_checkForSnappingCandidateNormalized(e,t,r,i,o,n){this._projectionRay(F,t,r,i,n),this._checkForSnappingCandidateAlongProjectedRay(e,t,r,F,i,o,n)}_projectionRay(e,t,r,i,o){this._projectionRayGeodesic(e,t,r,i,o)||this._projectionRayPlanar(e,t,r)}_projectionRayGeodesic(i,o,n,s,{spatialReference:a}){const p=R(o,n,a,a);if(null==p)return!1;const h=R(n,s,a,a);if(null==h)return!1;const g=Math.sign(e.shortestSignedDiff(p,h))*Math.PI*.5,l=t(p+g,"radians","geographic"),f=d(),m=S(n,s,a);return null!=m&&(y(f,n,a,r(m,"meters"),l,"geodesic"),c(i,f,n),!0)}_projectionRayPlanar(e,t,r){const o=i(C,m(r),m(t));p(e,o[1],-o[0],0)}_checkForSnappingCandidateAlongProjectedRay(e,t,r,a,c,p,f){const{spatialReference:j,pointer:R}=f,y=i(C,m(c),m(r)),S=o(a,y)/n(a),k=s(C,m(r),a,S),F=u(k[0],k[1],c[2]);if(v(p,E(F,j,g,this.view))>this.squaredProximityThreshold(R)||this.isVertical(F,r,f)||this.isVertical(r,t,f))return;const w=h(d(),r,a,Math.sign(S));e.push(new V({targetPoint:F,constraint:new l(r,x(w)),previousVertex:t,otherVertex:r,otherVertexType:_.CENTER,isDraped:"on-the-ground"===f.elevationInfo?.mode}))}}const C=a(),F=d();export{k as RightAngleSnapper};
