/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.29/esri/copyright.txt for details.
*/
import{valueInUnit as e,createLength as n,createAngle as t}from"../../../core/quantityUtils.js";import{verticalLengthUnitFromSpatialReference as r,lengthUnitFromSpatialReference as o}from"../../../core/unitUtils.js";import{f as i,c as u,g as l}from"../../../chunks/vec32.js";import{create as s}from"../../../core/libs/gl-matrix-2/factories/vec3f64.js";import{projectVectorToVector as c}from"../../../geometry/projection/projectVectorToVector.js";import{geodesicCompatibleSpatialReference as f}from"../../../geometry/support/geodesicUtils.js";import{getConvertedElevationFromXYZ as a}from"../../../support/elevationInfoUtils.js";import{constraintOrSet as m,VerticalCylinderConstraint as d,HorizontalPlaneConstraint as p,GeodesicConstraint as v,PointConstraint as g,VerticalHalfPlaneConstraint as R}from"../sketch/constraints.js";import{fromPoint as j,toElevationAlignedDehydratedPoint as w,fromVec3 as h}from"../sketch/normalizedPoint.js";import{getDegreesGeographic as S,DirectionMode as I,directionBetweenPoints as U,pointFromDistanceAlongAzimuth as y}from"../../support/angularMeasurementUtils.js";function M(e,n,t,r,o,i){let u="geodesic",l=f(t);const s=j(e,n,r);return s[2]=0,l&&c(s,t,s,l)||(u="euclidean",l=t),{mode:u,view:n,elevationInfo:r,hasZ:o,directionMode:i,spatialReference:e.spatialReference,measurementSR:l,origin:s}}function b(n,t,r){if(null==t||null==n)return;const i=o(r.measurementSR);if(null==i)return;const u=V(n,r);if(null==u)return;const l=e(t,i);return new d(h(u),l)}function k(e,n,r,o){if(null==r||null==e)return;const i=V(e,o);if(null==i)return;const u=S(r),l=10,c=e=>{if(null==e)return;const n=s(),r=t(e,"degrees","geographic");return y(n,i,o.measurementSR,l,r,o.mode)?new R(i,n):void 0},f=()=>{if(null!=n&&null!=e)return S(U(n,e))};switch(o.directionMode){case I.Absolute:return c(u);case I.Relative:{const e=f();if(null==e)return;return c(e+u)}case I.RelativeBilateral:{const e=f();if(null==e)return;return m([c(e+u),c(e-u)])}}}function Z(e,n){const t=z(e,n);return null!=t?new p(t):void 0}function x(n,t,r,o,i,u){if(null==r&&null==o&&null==i)return;if(null==t)return Z(o,u);const{view:l,elevationInfo:s,measurementSR:f}=u,a=j(t,l,s);if(!f||!c(a,t.spatialReference,D,f))return;const d=[D[0],D[1]],p=null!=r?e(r,"meters"):void 0,R=P(o,u),w=S(i),h=e=>{const n=new v(d,f,p,R,e);return null==p||null==e||null==R&&u.hasZ?n:new g(n.closestTo(a))};if(null==w)return h(void 0);const y=()=>{if(null!=n&&null!=t)return S(U(n,t))};switch(u.directionMode){case I.Absolute:return h(w);case I.Relative:{const e=y();if(null==e)return;return h(e+w)}case I.RelativeBilateral:{const e=y();if(null==e)return;return m([h(e+w),h(e-w)])}}}function A(e,n){return"geodesic"===n.mode?x(null,null,null,e,null,n):Z(e,n)}function B(e,n,t,r,o,i){return"geodesic"===i.mode?x(n,e,t,o,r,i):T([b(e,t,i),k(e,n,r,i),Z(o,i)])}function T(e){let n;for(const t of e)t&&(n=n?.intersect(t)??t);return n}function V(e,n){const{view:t,elevationInfo:r,measurementSR:o,origin:u,mode:l}=n,s=j(e,t,r);if(c(s,e.spatialReference,s,o))return"geodesic"!==l&&i(s,s,u),s}function q(e,n,t){const{view:r,measurementSR:o,spatialReference:i,origin:s,mode:f}=t,a=D;if("geodesic"===f?u(a,e):l(a,e,s),c(a,o,a,i))return w(a,r,n,t)}function z(e,n){return C(e,n)?.value??void 0}function P(n,t){const r=C(n,t);return null!=r?e(r,"meters"):void 0}function C(t,{view:o,origin:i,elevationInfo:u,hasZ:l,measurementSR:s}){if(null==t||!l)return;const c=r(s);if(null==c)return;const[f,m]=i,d=e(t,c),p="3d"===o?.type?a(o,f,m,d,s,u):d;return null!=p?n(p,c):void 0}const D=s();export{q as constraintSpaceToPoint,M as getConstraintContext,x as getGeodesicConstraint,A as getPointConstraint,B as getPolylineOrPolygonConstraint,T as intersectAll,V as pointToConstraintSpace};
