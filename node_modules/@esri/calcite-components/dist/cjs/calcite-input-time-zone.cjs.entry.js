/*!
 * All material copyright ESRI, All Rights Reserved, unless otherwise specified.
 * See https://github.com/Esri/calcite-design-system/blob/main/LICENSE.md for details.
 * v2.9.0
 */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const index = require('./index-0130b48b.js');
const label = require('./label-fc3be0da.js');
const interactive = require('./interactive-12c3fa24.js');
const locale = require('./locale-f24a94d6.js');
const t9n = require('./t9n-7ce07cfe.js');
const loadable = require('./loadable-8290f8f3.js');
const form = require('./form-3a8ea930.js');
require('./dom-8530141d.js');
require('./guid-752d9527.js');
require('./resources-5f767c3a.js');
require('./component-e5d703f3.js');
require('./browser-1161b139.js');
require('./key-f7bcdea2.js');
require('./observers-b8f934f3.js');

const hourToMinutes = 60;
const timeZoneNameBlockList = [
    "CET",
    "CST6CDT",
    "EET",
    "EST",
    "EST5EDT",
    "Factory",
    "HST",
    "MET",
    "MST",
    "MST7MDT",
    "PST8PDT",
    "UTC",
    "WET",
];
function timeZoneOffsetToDecimal(shortOffsetTimeZoneName) {
    const minusSign = "âˆ’";
    const hyphen = "-";
    return (shortOffsetTimeZoneName
        .replace(":15", ".25")
        .replace(":30", ".5")
        .replace(":45", ".75")
        // ensures decimal string representation is parseable
        .replace(minusSign, hyphen));
}
function toOffsetValue(timeZoneName, referenceDateInMs) {
    // we use "en-US" to allow us to reliably remove the standard time token
    const offset = getTimeZoneShortOffset(timeZoneName, "en-US", referenceDateInMs).replace("GMT", "");
    if (offset === "") {
        return 0;
    }
    return Number(timeZoneOffsetToDecimal(offset)) * hourToMinutes;
}
function getUserTimeZoneOffset() {
    const localDate = new Date();
    return localDate.getTimezoneOffset() * -1;
}
function getUserTimeZoneName() {
    const dateFormatter = new Intl.DateTimeFormat();
    return dateFormatter.resolvedOptions().timeZone;
}
/**
 * The lazy-loaded timezone-groups lib to be used across instances.
 */
let timeZoneGroups;
async function createTimeZoneItems(locale, messages, mode, referenceDate) {
    const referenceDateInMs = referenceDate.getTime();
    const timeZoneNames = Intl.supportedValuesOf("timeZone");
    if (mode === "offset") {
        if (!timeZoneGroups) {
            timeZoneGroups = Promise.all([
                Promise.resolve().then(function () { return require('./index-947fb3f4.js'); }),
                Promise.resolve().then(function () { return require('./index-718cfc8c.js'); }),
            ]);
        }
        return timeZoneGroups.then(async ([{ groupTimeZones }, { DateEngine }]) => {
            const timeZoneGroups = await groupTimeZones({
                dateEngine: new DateEngine(),
                groupDateRange: 1,
                startDate: new Date(referenceDateInMs).toISOString(),
            });
            const listFormatter = new Intl.ListFormat(locale, { style: "long", type: "conjunction" });
            // we remove blocked entries from tzs and adjust label indices accordingly
            timeZoneGroups.forEach((group) => {
                const indexOffsets = [];
                let removedSoFar = 0;
                group.tzs.forEach((tz, index) => {
                    if (timeZoneNameBlockList.includes(tz)) {
                        removedSoFar++;
                    }
                    indexOffsets[index] = removedSoFar;
                });
                group.tzs = group.tzs.filter((tz) => !timeZoneNameBlockList.includes(tz));
                group.labelTzIndices = group.labelTzIndices
                    .map((index) => index - indexOffsets[index])
                    .filter((index) => index >= 0 && index < group.tzs.length);
            });
            return timeZoneGroups
                .map(({ labelTzIndices, tzs }) => {
                const groupRepTz = tzs[0];
                const decimalOffset = timeZoneOffsetToDecimal(getTimeZoneShortOffset(groupRepTz, locale, referenceDateInMs));
                const value = toOffsetValue(groupRepTz, referenceDateInMs);
                const tzLabels = labelTzIndices.map((index) => {
                    const timeZone = tzs[index];
                    const timeZoneLabel = messages[timeZone];
                    return (timeZoneLabel ||
                        // get city token
                        timeZone.split("/").pop());
                });
                const label = createTimeZoneOffsetLabel(messages, decimalOffset, listFormatter.format(tzLabels));
                return {
                    label,
                    value,
                    filterValue: tzs.map((tz) => toUserFriendlyName(tz)),
                };
            })
                .filter((group) => !!group)
                .sort((groupA, groupB) => groupA.value - groupB.value);
        });
    }
    return timeZoneNames
        .map((timeZone) => {
        const label = toUserFriendlyName(timeZone);
        const value = timeZone;
        return {
            label,
            value,
            filterValue: timeZone,
        };
    })
        .filter((group) => !!group)
        .sort();
}
/**
 * Exported for testing purposes only
 *
 * @internal
 */
function toUserFriendlyName(timeZoneName) {
    return timeZoneName.replace(/_/g, " ");
}
function createTimeZoneOffsetLabel(messages, offsetLabel, groupLabel) {
    return messages.timeZoneLabel.replace("{offset}", offsetLabel).replace("{cities}", groupLabel);
}
function getTimeZoneShortOffset(timeZone, locale$1, referenceDateInMs = Date.now()) {
    const dateTimeFormat = locale.getDateTimeFormat(locale$1, { timeZone, timeZoneName: "shortOffset" });
    const parts = dateTimeFormat.formatToParts(referenceDateInMs);
    return parts.find(({ type }) => type === "timeZoneName").value;
}
function findTimeZoneItemByProp(timeZoneItems, prop, valueToMatch) {
    return valueToMatch == null
        ? null
        : timeZoneItems.find((item) => 
        // intentional == to match string to number
        item[prop] == valueToMatch);
}

const inputTimeZoneCss = ":host([disabled]){cursor:default;-webkit-user-select:none;user-select:none;opacity:var(--calcite-opacity-disabled)}:host([disabled]) *,:host([disabled]) ::slotted(*){pointer-events:none}:host{display:block}:host([hidden]){display:none}[hidden]{display:none}:host([disabled]) ::slotted([calcite-hydrated][disabled]),:host([disabled]) [calcite-hydrated][disabled]{opacity:1}.interaction-container{display:contents}::slotted(input[slot=hidden-form-input]){margin:0 !important;opacity:0 !important;outline:none !important;padding:0 !important;position:absolute !important;inset:0 !important;transform:none !important;-webkit-appearance:none !important;z-index:-1 !important}";
const CalciteInputTimeZoneStyle0 = inputTimeZoneCss;

const InputTimeZone = class {
    constructor(hostRef) {
        index.registerInstance(this, hostRef);
        this.calciteInputTimeZoneBeforeClose = index.createEvent(this, "calciteInputTimeZoneBeforeClose", 6);
        this.calciteInputTimeZoneBeforeOpen = index.createEvent(this, "calciteInputTimeZoneBeforeOpen", 6);
        this.calciteInputTimeZoneChange = index.createEvent(this, "calciteInputTimeZoneChange", 6);
        this.calciteInputTimeZoneClose = index.createEvent(this, "calciteInputTimeZoneClose", 6);
        this.calciteInputTimeZoneOpen = index.createEvent(this, "calciteInputTimeZoneOpen", 6);
        this.setComboboxRef = (el) => {
            this.comboboxEl = el;
        };
        this.onComboboxBeforeClose = (event) => {
            event.stopPropagation();
            this.calciteInputTimeZoneBeforeClose.emit();
        };
        this.onComboboxBeforeOpen = (event) => {
            event.stopPropagation();
            this.calciteInputTimeZoneBeforeOpen.emit();
        };
        this.onComboboxChange = (event) => {
            event.stopPropagation();
            const combobox = event.target;
            const selectedItem = combobox.selectedItems[0];
            if (!selectedItem) {
                this.value = null;
                this.selectedTimeZoneItem = null;
                this.calciteInputTimeZoneChange.emit();
                return;
            }
            const selected = this.findTimeZoneItemByLabel(selectedItem.textLabel);
            const selectedValue = `${selected.value}`;
            if (this.value === selectedValue && selected.label === this.selectedTimeZoneItem.label) {
                return;
            }
            this.value = selectedValue;
            this.selectedTimeZoneItem = selected;
            this.calciteInputTimeZoneChange.emit();
        };
        this.onComboboxClose = (event) => {
            event.stopPropagation();
            this.open = false;
            this.calciteInputTimeZoneClose.emit();
        };
        this.onComboboxOpen = (event) => {
            this.open = true;
            event.stopPropagation();
            this.calciteInputTimeZoneOpen.emit();
        };
        this.clearable = false;
        this.disabled = false;
        this.form = undefined;
        this.maxItems = 0;
        this.messages = undefined;
        this.messageOverrides = undefined;
        this.mode = "offset";
        this.validationMessage = undefined;
        this.validationIcon = undefined;
        this.validity = {
            valid: false,
            badInput: false,
            customError: false,
            patternMismatch: false,
            rangeOverflow: false,
            rangeUnderflow: false,
            stepMismatch: false,
            tooLong: false,
            tooShort: false,
            typeMismatch: false,
            valueMissing: false,
        };
        this.name = undefined;
        this.open = false;
        this.overlayPositioning = "absolute";
        this.referenceDate = undefined;
        this.required = false;
        this.scale = "m";
        this.status = "idle";
        this.value = undefined;
        this.readOnly = false;
        this.defaultMessages = undefined;
        this.effectiveLocale = "";
    }
    onMessagesChange() {
        /* wired up by t9n util */
    }
    handleTimeZoneItemPropsChange() {
        this.updateTimeZoneItemsAndSelection();
    }
    handleValueChange(value, oldValue) {
        value = this.normalizeValue(value);
        if (!value && this.clearable) {
            this.value = value;
            this.selectedTimeZoneItem = null;
            return;
        }
        const timeZoneItem = this.findTimeZoneItem(value);
        if (!timeZoneItem) {
            this.value = oldValue;
            return;
        }
        this.selectedTimeZoneItem = timeZoneItem;
    }
    //--------------------------------------------------------------------------
    //
    //  Public Methods
    //
    //--------------------------------------------------------------------------
    async setFocus() {
        await loadable.componentFocusable(this);
        await this.comboboxEl.setFocus();
    }
    effectiveLocaleWatcher() {
        t9n.updateMessages(this, this.effectiveLocale);
    }
    //--------------------------------------------------------------------------
    //
    //  Private Methods
    //
    //--------------------------------------------------------------------------
    onLabelClick() {
        this.setFocus();
    }
    findTimeZoneItem(value) {
        return findTimeZoneItemByProp(this.timeZoneItems, "value", value);
    }
    findTimeZoneItemByLabel(label) {
        return findTimeZoneItemByProp(this.timeZoneItems, "label", label);
    }
    async updateTimeZoneItemsAndSelection() {
        this.timeZoneItems = await this.createTimeZoneItems();
        if (this.value === "" && this.clearable) {
            this.selectedTimeZoneItem = null;
            return;
        }
        const fallbackValue = this.mode === "offset" ? getUserTimeZoneOffset() : getUserTimeZoneName();
        const valueToMatch = this.value ?? fallbackValue;
        this.selectedTimeZoneItem =
            this.findTimeZoneItem(valueToMatch) || this.findTimeZoneItem(fallbackValue);
    }
    async createTimeZoneItems() {
        if (!this.effectiveLocale || !this.messages) {
            return [];
        }
        return createTimeZoneItems(this.effectiveLocale, this.messages, this.mode, this.referenceDate instanceof Date
            ? this.referenceDate
            : new Date(this.referenceDate ?? Date.now()));
    }
    // --------------------------------------------------------------------------
    //
    //  Lifecycle
    //
    //--------------------------------------------------------------------------
    connectedCallback() {
        form.connectForm(this);
        label.connectLabel(this);
        locale.connectLocalized(this);
        t9n.connectMessages(this);
    }
    disconnectedCallback() {
        form.disconnectForm(this);
        label.disconnectLabel(this);
        locale.disconnectLocalized(this);
        t9n.disconnectMessages(this);
    }
    normalizeValue(value) {
        return value === null ? "" : value;
    }
    async componentWillLoad() {
        loadable.setUpLoadableComponent(this);
        await t9n.setUpMessages(this);
        this.value = this.normalizeValue(this.value);
        await this.updateTimeZoneItemsAndSelection();
        const selectedValue = this.selectedTimeZoneItem ? `${this.selectedTimeZoneItem.value}` : null;
        form.afterConnectDefaultValueSet(this, selectedValue);
        this.value = selectedValue;
    }
    componentDidLoad() {
        loadable.setComponentLoaded(this);
    }
    componentDidRender() {
        interactive.updateHostInteraction(this);
    }
    render() {
        return (index.h(index.Host, { key: '240ec55973f3b514109f4f7b37e180c50904396c' }, index.h(interactive.InteractiveContainer, { key: 'dd354cbb64a9207d5a8a76c8506addc4ad7a6cba', disabled: this.disabled }, index.h("calcite-combobox", { key: '5bcf50d77eedd614eeaa1884a77fa7c23549635c', clearDisabled: !this.clearable, disabled: this.disabled, label: this.messages.chooseTimeZone, lang: this.effectiveLocale, maxItems: this.maxItems, onCalciteComboboxBeforeClose: this.onComboboxBeforeClose, onCalciteComboboxBeforeOpen: this.onComboboxBeforeOpen, onCalciteComboboxChange: this.onComboboxChange, onCalciteComboboxClose: this.onComboboxClose, onCalciteComboboxOpen: this.onComboboxOpen, open: this.open, overlayPositioning: this.overlayPositioning, placeholder: this.mode === "name" ? this.messages.namePlaceholder : this.messages.offsetPlaceholder, readOnly: this.readOnly, ref: this.setComboboxRef, scale: this.scale, selectionMode: this.clearable ? "single" : "single-persist", status: this.status, "validation-icon": this.validationIcon, "validation-message": this.validationMessage }, this.timeZoneItems.map((group) => {
            const selected = this.selectedTimeZoneItem === group;
            const { label, value } = group;
            return (index.h("calcite-combobox-item", { "data-value": value, key: label, selected: selected, textLabel: label, value: `${group.filterValue}` }));
        })), index.h(form.HiddenFormInputSlot, { key: '8e430121c67530bded9a9060dea8f4d4f1de5457', component: this }))));
    }
    static get delegatesFocus() { return true; }
    static get assetsDirs() { return ["assets"]; }
    get el() { return index.getElement(this); }
    static get watchers() { return {
        "messageOverrides": ["onMessagesChange"],
        "messages": ["handleTimeZoneItemPropsChange"],
        "mode": ["handleTimeZoneItemPropsChange"],
        "referenceDate": ["handleTimeZoneItemPropsChange"],
        "value": ["handleValueChange"],
        "effectiveLocale": ["effectiveLocaleWatcher"]
    }; }
};
InputTimeZone.style = CalciteInputTimeZoneStyle0;

exports.calcite_input_time_zone = InputTimeZone;

//# sourceMappingURL=calcite-input-time-zone.cjs.entry.js.map